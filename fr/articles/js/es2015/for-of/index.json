{"head":{"layout":"Post","comments":true,"date":"2015-12-16","title":"ES6, ES2015 : la boucle for..of","tags":["javascript","ES6","ES2015","for..of"],"authors":["Freezystem"]},"body":"<h2 id=\"introduction\"><a class=\"markdownIt-Anchor\" href=\"#introduction\">#</a> Introduction</h2>\n<p>Avec l’arrivée de nouveaux objets itérables, ECMAScript avait la nécessité de s’enrichir de\nnouvelles façons de parcourir ces derniers. Dans l’unique soucis de maintenir la rétro-compatibilité\navec l’existant, l’ES6 se devait de garder la boucle <code>for..in</code> intacte.</p>\n<blockquote>\n<p>Mais alors, comment créer une variante de cette même boucle avec des capacités améliorées ?</p>\n</blockquote>\n<p>La solution est simple : “Bienvenue au mot clé <code>of</code> !”</p>\n<p>Mais avant d’en dire plus, et pour comprendre l’utilité de ce nouveau mot clé, revoyons un peu l’existant.</p>\n<h2 id=\"le-bon-vieux-for-in\"><a class=\"markdownIt-Anchor\" href=\"#le-bon-vieux-for-in\">#</a> Le bon vieux <code>for..in</code></h2>\n<p>Tout <em>JavaScript enthousiast</em> qui se respecte connaissait déjà la fameuse boucle <code>for..in</code>\ndont l’utilité première est d’itérer sur les différentes clés d’un objet ou d’un tableau.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> obj = { foo : <span class=\"hljs-string\">'hello'</span>, bar : <span class=\"hljs-string\">'world'</span> };\n\n<span class=\"hljs-keyword\">for</span> ( <span class=\"hljs-keyword\">const</span> key <span class=\"hljs-keyword\">in</span> obj ) {\n  <span class=\"hljs-built_in\">console</span>.log( key + <span class=\"hljs-string\">'-&gt;'</span> + obj[key] );  <span class=\"hljs-comment\">// 'foo-&gt;hello', 'bar-&gt;world'</span>\n}</code></pre>\n<p>La boucle <code>for..in</code>, malgré sont apparente simplicité d’utilisation cache certains pièges :</p>\n<ul>\n<li>\n<p>Lors de l’itération sur un tableau la valeur de l’index est convertis en chaine\nde caractères : “0”, “1”, “2”, etc… Ce qui peut potentiellement poser problème lors de\nl’utilisation de l’index dans des opérations de calcul.</p>\n</li>\n<li>\n<p>La boucle itère sur l’ensemble des clés du tableau, mais aussi sur chacune de ses propriétés.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-string\">'foo'</span>, <span class=\"hljs-string\">'bar'</span>];\narr.oups = <span class=\"hljs-string\">'baz'</span>;\n\n<span class=\"hljs-keyword\">for</span> ( <span class=\"hljs-keyword\">const</span> key <span class=\"hljs-keyword\">in</span> arr ) {\n  <span class=\"hljs-built_in\">console</span>.log( key + <span class=\"hljs-string\">'-&gt;'</span> + arr[key] ); <span class=\"hljs-comment\">// '0-&gt;foo', '1-&gt;bar', 'oups-&gt;baz'</span>\n}</code></pre>\n</li>\n<li>\n<p>L’ordre d’itération sur l’ensemble des clés d’un object peut varier selon l’environnement d’execution du code.</p>\n</li>\n</ul>\n<h2 id=\"la-methode-alternative-foreach\"><a class=\"markdownIt-Anchor\" href=\"#la-methode-alternative-foreach\">#</a> La methode alternative <code>.forEach()</code></h2>\n<p>La boucle <a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array/forEach\"><code>Array.prototype.forEach()</code></a>\npermet une itération plus sécurisé, mais présente certains autres inconvénients tels que :</p>\n<ul>\n<li>Impossibilité d’interrompre la boucle avec les instructions traditionnelles <code>break;</code> et <code>return;</code></li>\n<li>Méthode réservée aux tableaux.</li>\n</ul>\n<h2 id=\"for-of-la-rescousse\"><a class=\"markdownIt-Anchor\" href=\"#for-of-la-rescousse\">#</a> <code>for..of</code> à la rescousse</h2>\n<p>Le consortium ECMA a donc décidé de procéder à la création d’une nouvelle version améliorée\nde la boucle <code>for..in</code>. Ainsi nait la boucle <code>for..of</code> qui coexistera désormais avec la précédente\npermettant de maintenir la rétro-compatibilité avec les versions antérieures de la norme.</p>\n<p>Le principe est le même : parcourir n’importe quel type <em>d’objet itérable</em>.</p>\n<p>Dans sa forme la plus simple, la boucle <code>for..of</code> permet donc d’itérer sur l’ensemble des valeurs des clés d’un tableau.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-string\">'hello'</span>, <span class=\"hljs-string\">'world'</span>];\narr.baz = <span class=\"hljs-string\">'and mars'</span>;\n\n<span class=\"hljs-keyword\">for</span> ( <span class=\"hljs-keyword\">const</span> arrValue <span class=\"hljs-keyword\">of</span> arr ) {\n  <span class=\"hljs-built_in\">console</span>.log( arrValue ); <span class=\"hljs-comment\">// 'hello', 'world'</span>\n}</code></pre>\n<p>La boucle <code>for..of</code> peut aussi itérer sur des types plus complexes comme :</p>\n<h3 id=\"les-strings\"><a class=\"markdownIt-Anchor\" href=\"#les-strings\">#</a> les <em>Strings</em></h3>\n<p>Dans ce cas, chaque caractère est traité comme une entité Unicode.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> str = <span class=\"hljs-string\">'sm00th'</span>;\n\n<span class=\"hljs-keyword\">for</span> ( <span class=\"hljs-keyword\">const</span> chr <span class=\"hljs-keyword\">of</span> str ){\n  <span class=\"hljs-built_in\">console</span>.log(chr); <span class=\"hljs-comment\">// 's', 'm', '0', '0', 't', 'h'</span>\n}</code></pre>\n<h3 id=\"les-nodelist\"><a class=\"markdownIt-Anchor\" href=\"#les-nodelist\">#</a> les <em>NodeList</em></h3>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// <span class=\"hljs-doctag\">Note:</span> Cela ne fonctionnera que sur les environnements</span>\n<span class=\"hljs-comment\">// implémentant NodeList.prototype[Symbol.iterator]</span>\n\n<span class=\"hljs-comment\">// ce code ajoute une class \"read\" à toutes les balises &lt;p&gt;</span>\n<span class=\"hljs-comment\">// contenues dans la(les) balises &lt;article&gt;</span>\n\n<span class=\"hljs-keyword\">const</span> articleParagraphs = <span class=\"hljs-built_in\">document</span>.querySelectorAll(<span class=\"hljs-string\">\"article &gt; p\"</span>);\n\n<span class=\"hljs-keyword\">for</span> ( <span class=\"hljs-keyword\">const</span> paragraph <span class=\"hljs-keyword\">of</span> articleParagraphs ) {\n  paragraph.classList.add(<span class=\"hljs-string\">\"read\"</span>);\n}</code></pre>\n<h3 id=\"les-maps\"><a class=\"markdownIt-Anchor\" href=\"#les-maps\">#</a> les <em>Maps</em></h3>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> m = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>([[<span class=\"hljs-string\">'foo'</span>, <span class=\"hljs-string\">'hello'</span>], [<span class=\"hljs-string\">'bar'</span>, <span class=\"hljs-string\">'world'</span>]]);\n\n<span class=\"hljs-keyword\">for</span> ( <span class=\"hljs-keyword\">const</span> [name, value] <span class=\"hljs-keyword\">of</span> m ) {\n  <span class=\"hljs-built_in\">console</span>.log(name + <span class=\"hljs-string\">\"-&gt;\"</span> + value); <span class=\"hljs-comment\">//\"foo-&gt;hello\", \"bar-&gt;world\"</span>\n}</code></pre>\n<h3 id=\"les-sets\"><a class=\"markdownIt-Anchor\" href=\"#les-sets\">#</a> les <em>Sets</em></h3>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>([<span class=\"hljs-string\">'foo'</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-number\">42</span>]);\n\n<span class=\"hljs-keyword\">for</span> ( <span class=\"hljs-keyword\">const</span> value <span class=\"hljs-keyword\">of</span> s ) {\n  <span class=\"hljs-built_in\">console</span>.log(value); <span class=\"hljs-comment\">// 'foo', true, 42</span>\n}</code></pre>\n<h3 id=\"les-generators\"><a class=\"markdownIt-Anchor\" href=\"#les-generators\">#</a> les <em>Generators</em></h3>\n<pre><code class=\"language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">'foo'</span>;\n    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-literal\">false</span>;\n    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">42</span>;\n    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">'bar'</span>;\n}\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> v <span class=\"hljs-keyword\">of</span> foo() ) {\n    <span class=\"hljs-built_in\">console</span>.log( v ); <span class=\"hljs-comment\">// 'foo', false, 42, 'bar'</span>\n}</code></pre>\n<blockquote>\n<p>Et les objets traditionnels dans tout ça ?</p>\n</blockquote>\n<p>Etonnement, les objets ne peuvent pas être parcouru directement avec l’aide de\ncette nouvelle boucle. Heureusement il existe une solution de contournement\npar l’utilisation de <a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/keys\"><code>Object.keys()</code></a></p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> obj = { foo : <span class=\"hljs-string\">'hello'</span>, bar : <span class=\"hljs-string\">'world'</span> };\n\n<span class=\"hljs-keyword\">for</span> ( <span class=\"hljs-keyword\">const</span> key <span class=\"hljs-keyword\">of</span> <span class=\"hljs-built_in\">Object</span>.keys(obj) ) {\n  <span class=\"hljs-built_in\">console</span>.log(key + <span class=\"hljs-string\">\"-&gt;\"</span> + obj[key]); <span class=\"hljs-comment\">// 'foo-&gt;hello', 'bar-&gt;world'</span>\n}</code></pre>\n<h2 id=\"en-r-sum\"><a class=\"markdownIt-Anchor\" href=\"#en-r-sum\">#</a> En résumé</h2>\n<p><code>for..of</code> vient compléter les manques de <code>for..in</code> et permet\nune itération simplifiée sur les <em>objets itérables</em> tels que :</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array\">Array</a></li>\n<li><a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/String\">String</a></li>\n<li><a href=\"http://putaindecode.io/fr/articles/js/es2015/maps-weakmaps/\">Maps &amp; WeakMaps</a></li>\n<li><a href=\"http://putaindecode.io/fr/articles/js/es2015/sets-weaksets/\">Sets &amp; WeakSets</a></li>\n<li><a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/function*\">Generators</a></li>\n<li><a href=\"https://developer.mozilla.org/fr/docs/Web/API/NodeList\">NodeList</a></li>\n<li><a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Fonctions/arguments\">arguments</a></li>\n</ul>\n<p>De plus, <code>for..of</code> résout à présent les pièges tels que l’ordre d’itération non constant ou la coercion\nautomatique des index en chaine de caractères.</p>\n<h2 id=\"pour-aller-plus-loin\"><a class=\"markdownIt-Anchor\" href=\"#pour-aller-plus-loin\">#</a> Pour aller plus loin</h2>\n<p>La boucle <code>for..of</code> est donc une corde de plus à l’arc de l’ES6 qui\npermet de parcourir, de manière native, les tout nouveaux <em>objets itérables</em> du langage.</p>\n<p>Pour en savoir plus sur ses spécificités :</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/for...of\">Documentation MDN</a></li>\n<li><a href=\"https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/\">Le post de Jason Orendorff</a></li>\n<li><a href=\"http://tc39wiki.calculist.org/es6/for-of/\">Le post de Dave Herman</a></li>\n<li><a href=\"http://people.mozilla.org/~jorendorff/es6-draft.html#sec-for-in-and-for-of-statements\">Specification ECMA-262</a></li>\n</ul>\n","rawBody":"\n## Introduction\n\nAvec l'arrivée de nouveaux objets itérables, ECMAScript avait la nécessité de s'enrichir de\nnouvelles façons de parcourir ces derniers. Dans l'unique soucis de maintenir la rétro-compatibilité\navec l'existant, l'ES6 se devait de garder la boucle `for..in` intacte.\n\n> Mais alors, comment créer une variante de cette même boucle avec des capacités améliorées ?  \n\nLa solution est simple : \"Bienvenue au mot clé `of` !\"\n\nMais avant d'en dire plus, et pour comprendre l'utilité de ce nouveau mot clé, revoyons un peu l'existant.\n\n## Le bon vieux `for..in`\n\nTout _JavaScript enthousiast_ qui se respecte connaissait déjà la fameuse boucle `for..in`\ndont l'utilité première est d'itérer sur les différentes clés d'un objet ou d'un tableau.\n\n```js\nconst obj = { foo : 'hello', bar : 'world' };\n\nfor ( const key in obj ) {\n  console.log( key + '->' + obj[key] );  // 'foo->hello', 'bar->world'\n}\n```\n\nLa boucle `for..in`, malgré sont apparente simplicité d'utilisation cache certains pièges :\n - Lors de l'itération sur un tableau la valeur de l'index est convertis en chaine\n de caractères : \"0\", \"1\", \"2\", etc.. Ce qui peut potentiellement poser problème lors de\n l'utilisation de l'index dans des opérations de calcul.\n - La boucle itère sur l'ensemble des clés du tableau, mais aussi sur chacune de ses propriétés.\n\n    ```js\n    const arr = ['foo', 'bar'];\n    arr.oups = 'baz';\n\n    for ( const key in arr ) {\n      console.log( key + '->' + arr[key] ); // '0->foo', '1->bar', 'oups->baz'\n    }\n    ```\n - L'ordre d'itération sur l'ensemble des clés d'un object peut varier selon l'environnement d'execution du code.\n\n## La methode alternative `.forEach()`\n\nLa boucle [`Array.prototype.forEach()`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array/forEach)\npermet une itération plus sécurisé, mais présente certains autres inconvénients tels que :\n\n - Impossibilité d'interrompre la boucle avec les instructions traditionnelles `break;` et `return;`\n - Méthode réservée aux tableaux.\n\n## `for..of` à la rescousse\n\nLe consortium ECMA a donc décidé de procéder à la création d'une nouvelle version améliorée\nde la boucle `for..in`. Ainsi nait la boucle `for..of` qui coexistera désormais avec la précédente\npermettant de maintenir la rétro-compatibilité avec les versions antérieures de la norme.\n\nLe principe est le même : parcourir n'importe quel type _d'objet itérable_.\n\nDans sa forme la plus simple, la boucle `for..of` permet donc d'itérer sur l'ensemble des valeurs des clés d'un tableau.\n\n```js\nconst arr = ['hello', 'world'];\narr.baz = 'and mars';\n\nfor ( const arrValue of arr ) {\n  console.log( arrValue ); // 'hello', 'world'\n}\n```\n\nLa boucle `for..of` peut aussi itérer sur des types plus complexes comme :\n\n### les _Strings_\n\nDans ce cas, chaque caractère est traité comme une entité Unicode.\n\n```js\nconst str = 'sm00th';\n\nfor ( const chr of str ){\n  console.log(chr); // 's', 'm', '0', '0', 't', 'h'\n}\n```\n\n### les _NodeList_\n\n```js\n// Note: Cela ne fonctionnera que sur les environnements\n// implémentant NodeList.prototype[Symbol.iterator]\n\n// ce code ajoute une class \"read\" à toutes les balises <p>\n// contenues dans la(les) balises <article>\n\nconst articleParagraphs = document.querySelectorAll(\"article > p\");\n\nfor ( const paragraph of articleParagraphs ) {\n  paragraph.classList.add(\"read\");\n}\n```\n\n### les _Maps_\n\n```js\nconst m = new Map([['foo', 'hello'], ['bar', 'world']]);\n\nfor ( const [name, value] of m ) {\n  console.log(name + \"->\" + value); //\"foo->hello\", \"bar->world\"\n}\n```\n\n### les _Sets_\n\n```js\nconst s = new Set(['foo', true, 42]);\n\nfor ( const value of s ) {\n  console.log(value); // 'foo', true, 42\n}\n```\n\n### les _Generators_\n\n```js\nfunction *foo() {\n    yield 'foo';\n    yield false;\n    yield 42;\n    yield 'bar';\n}\n\nfor (const v of foo() ) {\n    console.log( v ); // 'foo', false, 42, 'bar'\n}\n```\n\n> Et les objets traditionnels dans tout ça ?\n\nEtonnement, les objets ne peuvent pas être parcouru directement avec l'aide de\ncette nouvelle boucle. Heureusement il existe une solution de contournement\npar l'utilisation de [`Object.keys()`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/keys)\n\n```js\nconst obj = { foo : 'hello', bar : 'world' };\n\nfor ( const key of Object.keys(obj) ) {\n  console.log(key + \"->\" + obj[key]); // 'foo->hello', 'bar->world'\n}\n```\n\n## En résumé\n\n`for..of` vient compléter les manques de `for..in` et permet\nune itération simplifiée sur les _objets itérables_ tels que :\n\n* [Array](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array)\n* [String](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/String)\n* [Maps & WeakMaps](http://putaindecode.io/fr/articles/js/es2015/maps-weakmaps/)\n* [Sets & WeakSets](http://putaindecode.io/fr/articles/js/es2015/sets-weaksets/)\n* [Generators](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/function*)\n* [NodeList](https://developer.mozilla.org/fr/docs/Web/API/NodeList)\n* [arguments](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Fonctions/arguments)\n\nDe plus, `for..of` résout à présent les pièges tels que l'ordre d'itération non constant ou la coercion\nautomatique des index en chaine de caractères.\n\n## Pour aller plus loin\n\nLa boucle `for..of` est donc une corde de plus à l'arc de l'ES6 qui\npermet de parcourir, de manière native, les tout nouveaux _objets itérables_ du langage.\n\nPour en savoir plus sur ses spécificités :\n\n* [Documentation MDN](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/for...of)\n* [Le post de Jason Orendorff](https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/)\n* [Le post de Dave Herman](http://tc39wiki.calculist.org/es6/for-of/)\n* [Specification ECMA-262](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-for-in-and-for-of-statements)\n","raw":"---\ndate: \"2015-12-16\"\ntitle: \"ES6, ES2015 : la boucle for..of\"\ntags:\n  - javascript\n  - ES6\n  - ES2015\n  - for..of\nauthors:\n  - Freezystem\n---\n\n## Introduction\n\nAvec l'arrivée de nouveaux objets itérables, ECMAScript avait la nécessité de s'enrichir de\nnouvelles façons de parcourir ces derniers. Dans l'unique soucis de maintenir la rétro-compatibilité\navec l'existant, l'ES6 se devait de garder la boucle `for..in` intacte.\n\n> Mais alors, comment créer une variante de cette même boucle avec des capacités améliorées ?  \n\nLa solution est simple : \"Bienvenue au mot clé `of` !\"\n\nMais avant d'en dire plus, et pour comprendre l'utilité de ce nouveau mot clé, revoyons un peu l'existant.\n\n## Le bon vieux `for..in`\n\nTout _JavaScript enthousiast_ qui se respecte connaissait déjà la fameuse boucle `for..in`\ndont l'utilité première est d'itérer sur les différentes clés d'un objet ou d'un tableau.\n\n```js\nconst obj = { foo : 'hello', bar : 'world' };\n\nfor ( const key in obj ) {\n  console.log( key + '->' + obj[key] );  // 'foo->hello', 'bar->world'\n}\n```\n\nLa boucle `for..in`, malgré sont apparente simplicité d'utilisation cache certains pièges :\n - Lors de l'itération sur un tableau la valeur de l'index est convertis en chaine\n de caractères : \"0\", \"1\", \"2\", etc.. Ce qui peut potentiellement poser problème lors de\n l'utilisation de l'index dans des opérations de calcul.\n - La boucle itère sur l'ensemble des clés du tableau, mais aussi sur chacune de ses propriétés.\n\n    ```js\n    const arr = ['foo', 'bar'];\n    arr.oups = 'baz';\n\n    for ( const key in arr ) {\n      console.log( key + '->' + arr[key] ); // '0->foo', '1->bar', 'oups->baz'\n    }\n    ```\n - L'ordre d'itération sur l'ensemble des clés d'un object peut varier selon l'environnement d'execution du code.\n\n## La methode alternative `.forEach()`\n\nLa boucle [`Array.prototype.forEach()`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array/forEach)\npermet une itération plus sécurisé, mais présente certains autres inconvénients tels que :\n\n - Impossibilité d'interrompre la boucle avec les instructions traditionnelles `break;` et `return;`\n - Méthode réservée aux tableaux.\n\n## `for..of` à la rescousse\n\nLe consortium ECMA a donc décidé de procéder à la création d'une nouvelle version améliorée\nde la boucle `for..in`. Ainsi nait la boucle `for..of` qui coexistera désormais avec la précédente\npermettant de maintenir la rétro-compatibilité avec les versions antérieures de la norme.\n\nLe principe est le même : parcourir n'importe quel type _d'objet itérable_.\n\nDans sa forme la plus simple, la boucle `for..of` permet donc d'itérer sur l'ensemble des valeurs des clés d'un tableau.\n\n```js\nconst arr = ['hello', 'world'];\narr.baz = 'and mars';\n\nfor ( const arrValue of arr ) {\n  console.log( arrValue ); // 'hello', 'world'\n}\n```\n\nLa boucle `for..of` peut aussi itérer sur des types plus complexes comme :\n\n### les _Strings_\n\nDans ce cas, chaque caractère est traité comme une entité Unicode.\n\n```js\nconst str = 'sm00th';\n\nfor ( const chr of str ){\n  console.log(chr); // 's', 'm', '0', '0', 't', 'h'\n}\n```\n\n### les _NodeList_\n\n```js\n// Note: Cela ne fonctionnera que sur les environnements\n// implémentant NodeList.prototype[Symbol.iterator]\n\n// ce code ajoute une class \"read\" à toutes les balises <p>\n// contenues dans la(les) balises <article>\n\nconst articleParagraphs = document.querySelectorAll(\"article > p\");\n\nfor ( const paragraph of articleParagraphs ) {\n  paragraph.classList.add(\"read\");\n}\n```\n\n### les _Maps_\n\n```js\nconst m = new Map([['foo', 'hello'], ['bar', 'world']]);\n\nfor ( const [name, value] of m ) {\n  console.log(name + \"->\" + value); //\"foo->hello\", \"bar->world\"\n}\n```\n\n### les _Sets_\n\n```js\nconst s = new Set(['foo', true, 42]);\n\nfor ( const value of s ) {\n  console.log(value); // 'foo', true, 42\n}\n```\n\n### les _Generators_\n\n```js\nfunction *foo() {\n    yield 'foo';\n    yield false;\n    yield 42;\n    yield 'bar';\n}\n\nfor (const v of foo() ) {\n    console.log( v ); // 'foo', false, 42, 'bar'\n}\n```\n\n> Et les objets traditionnels dans tout ça ?\n\nEtonnement, les objets ne peuvent pas être parcouru directement avec l'aide de\ncette nouvelle boucle. Heureusement il existe une solution de contournement\npar l'utilisation de [`Object.keys()`](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/keys)\n\n```js\nconst obj = { foo : 'hello', bar : 'world' };\n\nfor ( const key of Object.keys(obj) ) {\n  console.log(key + \"->\" + obj[key]); // 'foo->hello', 'bar->world'\n}\n```\n\n## En résumé\n\n`for..of` vient compléter les manques de `for..in` et permet\nune itération simplifiée sur les _objets itérables_ tels que :\n\n* [Array](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array)\n* [String](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/String)\n* [Maps & WeakMaps](http://putaindecode.io/fr/articles/js/es2015/maps-weakmaps/)\n* [Sets & WeakSets](http://putaindecode.io/fr/articles/js/es2015/sets-weaksets/)\n* [Generators](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/function*)\n* [NodeList](https://developer.mozilla.org/fr/docs/Web/API/NodeList)\n* [arguments](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Fonctions/arguments)\n\nDe plus, `for..of` résout à présent les pièges tels que l'ordre d'itération non constant ou la coercion\nautomatique des index en chaine de caractères.\n\n## Pour aller plus loin\n\nLa boucle `for..of` est donc une corde de plus à l'arc de l'ES6 qui\npermet de parcourir, de manière native, les tout nouveaux _objets itérables_ du langage.\n\nPour en savoir plus sur ses spécificités :\n\n* [Documentation MDN](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/for...of)\n* [Le post de Jason Orendorff](https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/)\n* [Le post de Dave Herman](http://tc39wiki.calculist.org/es6/for-of/)\n* [Specification ECMA-262](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-for-in-and-for-of-statements)\n","__filename":"fr/articles/js/es2015/for-of.md","__url":"/fr/articles/js/es2015/for-of/"}