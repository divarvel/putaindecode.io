{"head":{"layout":"Post","comments":true,"date":"2015-12-13","title":"ES6, ES2015 : les nouvelles méthode d'Array","tags":["javascript","ES6","ES2015"],"authors":["lionelB"]},"body":"<p><s>ES6</s>  ES2015 enrichit les objets de la bibiliothèque standard de nouvelles fonctionnalités.\nVoici les nouveautés que l’on va trouver dans <code>Array</code>.</p>\n<h2 id=\"array-from\"><a class=\"markdownIt-Anchor\" href=\"#array-from\">#</a> Array.from()</h2>\n<p>Parmi les nouvelles méthodes ajoutées à Array, <code>Array.from()</code> est peut être celle que vous allez utiliser le plus souvent. Elle va nous permettre de créer un tableau à partir d’un itérable ou d’un objet qui ressemble à un tableau comme une NodeList, ou encore <code>arguments</code>.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> nodes = <span class=\"hljs-built_in\">Array</span>.from(<span class=\"hljs-built_in\">document</span>.querySeletorAll(<span class=\"hljs-string\">'div'</span>))\nnodes.forEach(node =&gt; <span class=\"hljs-built_in\">console</span>.log(node))</code></pre>\n<h2 id=\"array-of\"><a class=\"markdownIt-Anchor\" href=\"#array-of\">#</a> Array.of()</h2>\n<p>Cette méthode va permettre de créer un tableau à partir des arguments reçus.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> arr = <span class=\"hljs-built_in\">Array</span>.of(<span class=\"hljs-string\">\"hello\"</span>, <span class=\"hljs-string\">\"world\"</span>)\n<span class=\"hljs-built_in\">console</span>.log(arr.join(<span class=\"hljs-string\">\" \"</span>)) <span class=\"hljs-comment\">// \"hello world\"</span></code></pre>\n<h2 id=\"array-proptotype-keys-array-prototype-entries\"><a class=\"markdownIt-Anchor\" href=\"#array-proptotype-keys-array-prototype-entries\">#</a> Array.proptotype.keys() &amp; Array.prototype.entries()</h2>\n<p>On retrouve aussi ces méthodes sur d’autres itérables comme Map ou Set.\n<code>Array.prototype.keys()</code> va renvoyer un nouveau tableau dont les valeurs seront les clefs du tableau passé en paramêtre.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> arr =  [...Array(<span class=\"hljs-number\">3</span>).keys()]\n<span class=\"hljs-built_in\">console</span>.log(arr) <span class=\"hljs-comment\">// [0,1,2]</span></code></pre>\n<p><code>Array.prototype.entries()</code> quant à lui va renvoyer un tableau composé des paires clé,valeur</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-string\">\"hello\"</span>, <span class=\"hljs-string\">\"world\"</span>]\n<span class=\"hljs-built_in\">console</span>.log(arr.entries()) <span class=\"hljs-comment\">// [[0, \"hello\"], [1, \"world\"]]</span></code></pre>\n<h2 id=\"array-prototype-find\"><a class=\"markdownIt-Anchor\" href=\"#array-prototype-find\">#</a> Array.prototype.find()</h2>\n<p>Cette méthode va permettre de renvoyer une valeur contenue dans le tableau si celle ci vérifie\nla condition définie par la fonction de prédicat passée en paramêtre. On retrouve le même principe qu’avec <code>filter</code>, <code>some</code> et <code>every</code>. Si aucune valeur ne\nvalide la fonction de prédicat, alors la méthode renverra <code>undefined</code>.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> arr = [{id:<span class=\"hljs-number\">1</span>, label:<span class=\"hljs-string\">\"hello\"</span>}, {id:<span class=\"hljs-number\">2</span>, name: <span class=\"hljs-string\">\"world\"</span>}]\n<span class=\"hljs-keyword\">const</span> found = arr.find(item =&gt; item.id === <span class=\"hljs-number\">2</span>)\n<span class=\"hljs-keyword\">const</span> notfound = arr.find(item =&gt; item.id === <span class=\"hljs-number\">3</span>)\n<span class=\"hljs-built_in\">console</span>.log(found, notfound) <span class=\"hljs-comment\">// {id:2, name: \"worl\"}, undefined</span></code></pre>\n<p>À noter qu’il existe aussi <code>Array.prototype.findIndex()</code> qui renverra non pas l’objet, mais l’index de l’objet qui validera la fonction de prédicat</p>\n<h2 id=\"array-prototype-fill\"><a class=\"markdownIt-Anchor\" href=\"#array-prototype-fill\">#</a> Array.prototype.fill()</h2>\n<p>Cette méthode va permettre de remplir un tableau avec une valeur passée en paramêtre. Il est toutefois possible de définir un index de début et un index de fin (comme avec slice par exemple), si l’on souhaite remplacer qu’une partie du tableau.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> arr = <span class=\"hljs-built_in\">Array</span>(<span class=\"hljs-number\">3</span>).fill(<span class=\"hljs-number\">1</span>)\n<span class=\"hljs-built_in\">console</span>.log(arr) <span class=\"hljs-comment\">// [1,1,1]</span></code></pre>\n<h2 id=\"array-prototype-copywithin\"><a class=\"markdownIt-Anchor\" href=\"#array-prototype-copywithin\">#</a> Array.prototype.copyWithin()</h2>\n<p>Cette méthode va permettre de renvoyer un nouveau tableau en remplaçant une partie du tableau par une séquence de ce dernier. Pour cela on va indiquer à partir de quel index l’on souhaite démarrer la copie de la sequence ainsi que l’index de début et de fin de la séquence que l’on souhaite voir répéter.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-string\">\"hello\"</span>,<span class=\"hljs-string\">\"alice\"</span>, <span class=\"hljs-string\">\"my\"</span>, <span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"is\"</span> <span class=\"hljs-string\">\"bob\"</span>]\n<span class=\"hljs-built_in\">console</span>.log(arr.copyWithin(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>)]) <span class=\"hljs-comment\">//  \"hello\",\"bob\", \"my\", \"name\", \"is\" \"bob\"]</span></code></pre>\n<p>Certaines méthodes paraissent pas forcément super utiles alors n’hésitez à utiliser les commentaires pour partager des exemples d’utilisation plus intéressants :p</p>\n","rawBody":"\n~~ES6~~  ES2015 enrichit les objets de la bibiliothèque standard de nouvelles fonctionnalités.\nVoici les nouveautés que l'on va trouver dans `Array`.\n\n## Array.from()\n\nParmi les nouvelles méthodes ajoutées à Array, `Array.from()` est peut être celle que vous allez utiliser le plus souvent. Elle va nous permettre de créer un tableau à partir d'un itérable ou d'un objet qui ressemble à un tableau comme une NodeList, ou encore `arguments`.\n\n```javascript\nconst nodes = Array.from(document.querySeletorAll('div'))\nnodes.forEach(node => console.log(node))\n```\n\n## Array.of()\n\nCette méthode va permettre de créer un tableau à partir des arguments reçus.\n\n```javascript\nconst arr = Array.of(\"hello\", \"world\")\nconsole.log(arr.join(\" \")) // \"hello world\"\n```\n\n## Array.proptotype.keys() & Array.prototype.entries()\n\nOn retrouve aussi ces méthodes sur d'autres itérables comme Map ou Set.\n`Array.prototype.keys()` va renvoyer un nouveau tableau dont les valeurs seront les clefs du tableau passé en paramêtre. \n\n```javascript\nconst arr =  [...Array(3).keys()]\nconsole.log(arr) // [0,1,2]\n```\n\n`Array.prototype.entries()` quant à lui va renvoyer un tableau composé des paires clé,valeur\n\n```javascript\nconst arr = [\"hello\", \"world\"]\nconsole.log(arr.entries()) // [[0, \"hello\"], [1, \"world\"]]\n```\n\n## Array.prototype.find()\n\nCette méthode va permettre de renvoyer une valeur contenue dans le tableau si celle ci vérifie \nla condition définie par la fonction de prédicat passée en paramêtre. On retrouve le même principe qu'avec `filter`, `some` et `every`. Si aucune valeur ne \nvalide la fonction de prédicat, alors la méthode renverra `undefined`.\n\n```javascript\nconst arr = [{id:1, label:\"hello\"}, {id:2, name: \"world\"}]\nconst found = arr.find(item => item.id === 2)\nconst notfound = arr.find(item => item.id === 3)\nconsole.log(found, notfound) // {id:2, name: \"worl\"}, undefined\n```\n\nÀ noter qu'il existe aussi `Array.prototype.findIndex()` qui renverra non pas l'objet, mais l'index de l'objet qui validera la fonction de prédicat\n\n## Array.prototype.fill()\n\nCette méthode va permettre de remplir un tableau avec une valeur passée en paramêtre. Il est toutefois possible de définir un index de début et un index de fin (comme avec slice par exemple), si l'on souhaite remplacer qu'une partie du tableau.\n\n```javascript\nconst arr = Array(3).fill(1)\nconsole.log(arr) // [1,1,1]\n```\n\n## Array.prototype.copyWithin()\n\nCette méthode va permettre de renvoyer un nouveau tableau en remplaçant une partie du tableau par une séquence de ce dernier. Pour cela on va indiquer à partir de quel index l'on souhaite démarrer la copie de la sequence ainsi que l'index de début et de fin de la séquence que l'on souhaite voir répéter.\n\n```javascript\nconst arr = [\"hello\",\"alice\", \"my\", \"name\", \"is\" \"bob\"]\nconsole.log(arr.copyWithin(1, 5)]) //  \"hello\",\"bob\", \"my\", \"name\", \"is\" \"bob\"]\n```\n\nCertaines méthodes paraissent pas forcément super utiles alors n'hésitez à utiliser les commentaires pour partager des exemples d'utilisation plus intéressants :p\n\n\n\n\n\n\n\n\n","raw":"---\ndate: \"2015-12-13\"\ntitle: \"ES6, ES2015 : les nouvelles méthode d'Array\"\ntags:\n  - javascript\n  - ES6\n  - ES2015\nauthors:\n  - lionelB\n---\n\n~~ES6~~  ES2015 enrichit les objets de la bibiliothèque standard de nouvelles fonctionnalités.\nVoici les nouveautés que l'on va trouver dans `Array`.\n\n## Array.from()\n\nParmi les nouvelles méthodes ajoutées à Array, `Array.from()` est peut être celle que vous allez utiliser le plus souvent. Elle va nous permettre de créer un tableau à partir d'un itérable ou d'un objet qui ressemble à un tableau comme une NodeList, ou encore `arguments`.\n\n```javascript\nconst nodes = Array.from(document.querySeletorAll('div'))\nnodes.forEach(node => console.log(node))\n```\n\n## Array.of()\n\nCette méthode va permettre de créer un tableau à partir des arguments reçus.\n\n```javascript\nconst arr = Array.of(\"hello\", \"world\")\nconsole.log(arr.join(\" \")) // \"hello world\"\n```\n\n## Array.proptotype.keys() & Array.prototype.entries()\n\nOn retrouve aussi ces méthodes sur d'autres itérables comme Map ou Set.\n`Array.prototype.keys()` va renvoyer un nouveau tableau dont les valeurs seront les clefs du tableau passé en paramêtre. \n\n```javascript\nconst arr =  [...Array(3).keys()]\nconsole.log(arr) // [0,1,2]\n```\n\n`Array.prototype.entries()` quant à lui va renvoyer un tableau composé des paires clé,valeur\n\n```javascript\nconst arr = [\"hello\", \"world\"]\nconsole.log(arr.entries()) // [[0, \"hello\"], [1, \"world\"]]\n```\n\n## Array.prototype.find()\n\nCette méthode va permettre de renvoyer une valeur contenue dans le tableau si celle ci vérifie \nla condition définie par la fonction de prédicat passée en paramêtre. On retrouve le même principe qu'avec `filter`, `some` et `every`. Si aucune valeur ne \nvalide la fonction de prédicat, alors la méthode renverra `undefined`.\n\n```javascript\nconst arr = [{id:1, label:\"hello\"}, {id:2, name: \"world\"}]\nconst found = arr.find(item => item.id === 2)\nconst notfound = arr.find(item => item.id === 3)\nconsole.log(found, notfound) // {id:2, name: \"worl\"}, undefined\n```\n\nÀ noter qu'il existe aussi `Array.prototype.findIndex()` qui renverra non pas l'objet, mais l'index de l'objet qui validera la fonction de prédicat\n\n## Array.prototype.fill()\n\nCette méthode va permettre de remplir un tableau avec une valeur passée en paramêtre. Il est toutefois possible de définir un index de début et un index de fin (comme avec slice par exemple), si l'on souhaite remplacer qu'une partie du tableau.\n\n```javascript\nconst arr = Array(3).fill(1)\nconsole.log(arr) // [1,1,1]\n```\n\n## Array.prototype.copyWithin()\n\nCette méthode va permettre de renvoyer un nouveau tableau en remplaçant une partie du tableau par une séquence de ce dernier. Pour cela on va indiquer à partir de quel index l'on souhaite démarrer la copie de la sequence ainsi que l'index de début et de fin de la séquence que l'on souhaite voir répéter.\n\n```javascript\nconst arr = [\"hello\",\"alice\", \"my\", \"name\", \"is\" \"bob\"]\nconsole.log(arr.copyWithin(1, 5)]) //  \"hello\",\"bob\", \"my\", \"name\", \"is\" \"bob\"]\n```\n\nCertaines méthodes paraissent pas forcément super utiles alors n'hésitez à utiliser les commentaires pour partager des exemples d'utilisation plus intéressants :p\n\n\n\n\n\n\n\n\n","__filename":"fr/articles/js/es2015/array-methods-addition.md","__url":"/fr/articles/js/es2015/array-methods-addition/"}