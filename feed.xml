<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[putaindecode.io]]></title><description><![CDATA[putaindecode.io]]></description><link>http://putaindecode.io</link><generator>RSS for Node</generator><lastBuildDate>Sat, 19 Dec 2015 19:00:15 GMT</lastBuildDate><atom:link href="http://putaindecode.io/feed.xml" rel="self" type="application/rss+xml"/><item><title><![CDATA[ES6, ES2015 : la boucle for..of]]></title><description><![CDATA[<h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction">#</a> Introduction</h2>
<p>Avec l’arrivée de nouveaux objets itérables, ECMAScript avait la nécessité de s’enrichir de
nouvelles façons de parcourir ces derniers. Dans l’unique soucis de maintenir la rétro-compatibilité
avec l’existant, l’ES6 se devait de garder la boucle <code>for..in</code> intacte.</p>
<blockquote>
<p>Mais alors, comment créer une variante de cette même boucle avec des capacités améliorées ?</p>
</blockquote>
<p>La solution est simple : “Bienvenue au mot clé <code>of</code> !”</p>
<p>Mais avant d’en dire plus, et pour comprendre l’utilité de ce nouveau mot clé, revoyons un peu l’existant.</p>
<h2 id="le-bon-vieux-for-in"><a class="markdownIt-Anchor" href="#le-bon-vieux-for-in">#</a> Le bon vieux <code>for..in</code></h2>
<p>Tout <em>JavaScript enthousiast</em> qui se respecte connaissait déjà la fameuse boucle <code>for..in</code>
dont l’utilité première est d’itérer sur les différentes clés d’un objet ou d’un tableau.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> obj = { foo : <span class="hljs-string">'hello'</span>, bar : <span class="hljs-string">'world'</span> };

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj ) {
  <span class="hljs-built_in">console</span>.log( key + <span class="hljs-string">'-&gt;'</span> + obj[key] );  <span class="hljs-comment">// 'foo-&gt;hello', 'bar-&gt;world'</span>
}</code></pre>
<p>La boucle <code>for..in</code>, malgré sont apparente simplicité d’utilisation cache certains pièges :</p>
<ul>
<li>
<p>Lors de l’itération sur un tableau la valeur de l’index est convertis en chaine
de caractères : “0”, “1”, “2”, etc… Ce qui peut potentiellement poser problème lors de
l’utilisation de l’index dans des opérations de calcul.</p>
</li>
<li>
<p>La boucle itère sur l’ensemble des clés du tableau, mais aussi sur chacune de ses propriétés.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>];
arr.oups = <span class="hljs-string">'baz'</span>;

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> arr ) {
  <span class="hljs-built_in">console</span>.log( key + <span class="hljs-string">'-&gt;'</span> + arr[key] ); <span class="hljs-comment">// '0-&gt;foo', '1-&gt;bar', 'oups-&gt;baz'</span>
}</code></pre>
</li>
<li>
<p>L’ordre d’itération sur l’ensemble des clés d’un object peut varier selon l’environnement d’execution du code.</p>
</li>
</ul>
<h2 id="la-methode-alternative-foreach"><a class="markdownIt-Anchor" href="#la-methode-alternative-foreach">#</a> La methode alternative <code>.forEach()</code></h2>
<p>La boucle <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array/forEach"><code>Array.prototype.forEach()</code></a>
permet une itération plus sécurisé, mais présente certains autres inconvénients tels que :</p>
<ul>
<li>Impossibilité d’interrompre la boucle avec les instructions traditionnelles <code>break;</code> et <code>return;</code></li>
<li>Méthode réservée aux tableaux.</li>
</ul>
<h2 id="for-of-la-rescousse"><a class="markdownIt-Anchor" href="#for-of-la-rescousse">#</a> <code>for..of</code> à la rescousse</h2>
<p>Le consortium ECMA a donc décidé de procéder à la création d’une nouvelle version améliorée
de la boucle <code>for..in</code>. Ainsi nait la boucle <code>for..of</code> qui coexistera désormais avec la précédente
permettant de maintenir la rétro-compatibilité avec les versions antérieures de la norme.</p>
<p>Le principe est le même : parcourir n’importe quel type <em>d’objet itérable</em>.</p>
<p>Dans sa forme la plus simple, la boucle <code>for..of</code> permet donc d’itérer sur l’ensemble des valeurs des clés d’un tableau.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>];
arr.baz = <span class="hljs-string">'and mars'</span>;

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> arrValue <span class="hljs-keyword">of</span> arr ) {
  <span class="hljs-built_in">console</span>.log( arrValue ); <span class="hljs-comment">// 'hello', 'world'</span>
}</code></pre>
<p>La boucle <code>for..of</code> peut aussi itérer sur des types plus complexes comme :</p>
<h3 id="les-strings"><a class="markdownIt-Anchor" href="#les-strings">#</a> les <em>Strings</em></h3>
<p>Dans ce cas, chaque caractère est traité comme une entité Unicode.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">'sm00th'</span>;

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> chr <span class="hljs-keyword">of</span> str ){
  <span class="hljs-built_in">console</span>.log(chr); <span class="hljs-comment">// 's', 'm', '0', '0', 't', 'h'</span>
}</code></pre>
<h3 id="les-nodelist"><a class="markdownIt-Anchor" href="#les-nodelist">#</a> les <em>NodeList</em></h3>
<pre><code class="language-js"><span class="hljs-comment">// <span class="hljs-doctag">Note:</span> Cela ne fonctionnera que sur les environnements</span>
<span class="hljs-comment">// implémentant NodeList.prototype[Symbol.iterator]</span>

<span class="hljs-comment">// ce code ajoute une class "read" à toutes les balises &lt;p&gt;</span>
<span class="hljs-comment">// contenues dans la(les) balises &lt;article&gt;</span>

<span class="hljs-keyword">const</span> articleParagraphs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">"article &gt; p"</span>);

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> paragraph <span class="hljs-keyword">of</span> articleParagraphs ) {
  paragraph.classList.add(<span class="hljs-string">"read"</span>);
}</code></pre>
<h3 id="les-maps"><a class="markdownIt-Anchor" href="#les-maps">#</a> les <em>Maps</em></h3>
<pre><code class="language-js"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">'foo'</span>, <span class="hljs-string">'hello'</span>], [<span class="hljs-string">'bar'</span>, <span class="hljs-string">'world'</span>]]);

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> [name, value] <span class="hljs-keyword">of</span> m ) {
  <span class="hljs-built_in">console</span>.log(name + <span class="hljs-string">"-&gt;"</span> + value); <span class="hljs-comment">//"foo-&gt;hello", "bar-&gt;world"</span>
}</code></pre>
<h3 id="les-sets"><a class="markdownIt-Anchor" href="#les-sets">#</a> les <em>Sets</em></h3>
<pre><code class="language-js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">'foo'</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">42</span>]);

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> s ) {
  <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// 'foo', true, 42</span>
}</code></pre>
<h3 id="les-generators"><a class="markdownIt-Anchor" href="#les-generators">#</a> les <em>Generators</em></h3>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'foo'</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-number">42</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'bar'</span>;
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> v <span class="hljs-keyword">of</span> foo() ) {
    <span class="hljs-built_in">console</span>.log( v ); <span class="hljs-comment">// 'foo', false, 42, 'bar'</span>
}</code></pre>
<blockquote>
<p>Et les objets traditionnels dans tout ça ?</p>
</blockquote>
<p>Etonnement, les objets ne peuvent pas être parcouru directement avec l’aide de
cette nouvelle boucle. Heureusement il existe une solution de contournement
par l’utilisation de <a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/keys"><code>Object.keys()</code></a></p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> obj = { foo : <span class="hljs-string">'hello'</span>, bar : <span class="hljs-string">'world'</span> };

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(obj) ) {
  <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">"-&gt;"</span> + obj[key]); <span class="hljs-comment">// 'foo-&gt;hello', 'bar-&gt;world'</span>
}</code></pre>
<h2 id="en-r-sum"><a class="markdownIt-Anchor" href="#en-r-sum">#</a> En résumé</h2>
<p><code>for..of</code> vient compléter les manques de <code>for..in</code> et permet
une itération simplifiée sur les <em>objets itérables</em> tels que :</p>
<ul>
<li><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Array">Array</a></li>
<li><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/String">String</a></li>
<li><a href="http://putaindecode.io/fr/articles/js/es2015/maps-weakmaps/">Maps &amp; WeakMaps</a></li>
<li><a href="http://putaindecode.io/fr/articles/js/es2015/sets-weaksets/">Sets &amp; WeakSets</a></li>
<li><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/function*">Generators</a></li>
<li><a href="https://developer.mozilla.org/fr/docs/Web/API/NodeList">NodeList</a></li>
<li><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Fonctions/arguments">arguments</a></li>
</ul>
<p>De plus, <code>for..of</code> résout à présent les pièges tels que l’ordre d’itération non constant ou la coercion
automatique des index en chaine de caractères.</p>
<h2 id="pour-aller-plus-loin"><a class="markdownIt-Anchor" href="#pour-aller-plus-loin">#</a> Pour aller plus loin</h2>
<p>La boucle <code>for..of</code> est donc une corde de plus à l’arc de l’ES6 qui
permet de parcourir, de manière native, les tout nouveaux <em>objets itérables</em> du langage.</p>
<p>Pour en savoir plus sur ses spécificités :</p>
<ul>
<li><a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/for...of">Documentation MDN</a></li>
<li><a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/">Le post de Jason Orendorff</a></li>
<li><a href="http://tc39wiki.calculist.org/es6/for-of/">Le post de Dave Herman</a></li>
<li><a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-for-in-and-for-of-statements">Specification ECMA-262</a></li>
</ul>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/for-of/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/for-of/</guid><pubDate>Wed, 16 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : for..of loop]]></title><description><![CDATA[<h2 id="introduction"><a class="markdownIt-Anchor" href="#introduction">#</a> Introduction</h2>
<p>With the arrival of new iterable objects, ECMAScript had to create new ways to read through them.
In the unique concern of maintaining the backward compatibility, ES6 had to const his <code>for..in</code> loop untouched.</p>
<blockquote>
<p>But then, how to create a copycat of this same loop with improved capabilities ?</p>
</blockquote>
<p>Solution is quite simple: “Welcome to the <code>of</code> keyword!”</p>
<p>But before I tell you more, and to fully understand the usefulness of this new keyword, const review the existing.</p>
<h2 id="the-good-ol-for-in"><a class="markdownIt-Anchor" href="#the-good-ol-for-in">#</a> The good ol’ <code>for..in</code></h2>
<p>All self-respecting <em>JavaScript enthousiast</em> already knows the famous <code>for..in</code> loop
whose first value is to iterate over the different keys of an object or an array.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> obj = { foo : <span class="hljs-string">'hello'</span>, bar : <span class="hljs-string">'world'</span> };

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj ) {
  <span class="hljs-built_in">console</span>.log( key + <span class="hljs-string">'-&gt;'</span> + obj[key] );  <span class="hljs-comment">// 'foo-&gt;hello', 'bar-&gt;world'</span>
}</code></pre>
<p>The <code>for..in</code> loop, despite its ease of use hide some pitfalls:</p>
<ul>
<li>
<p>When itarating over an array, index value is parsed to string : “0”, “1”, “2”, etc…
This behaviour can lead to potential error when index is used in computation.</p>
</li>
<li>
<p>The loop iterate across all the table keys, but also over each of its properties.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>];
arr.oups = <span class="hljs-string">'baz'</span>;

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> arr ) {
  <span class="hljs-built_in">console</span>.log( key + <span class="hljs-string">'-&gt;'</span> + arr[key] ); <span class="hljs-comment">// '0-&gt;foo', '1-&gt;bar', 'oups-&gt;baz'</span>
}</code></pre>
</li>
<li>
<p>Iteration order over a given object properties may vary across depending on the code executing environment.</p>
</li>
</ul>
<h2 id="the-alternative-foreach-method"><a class="markdownIt-Anchor" href="#the-alternative-foreach-method">#</a> The alternative <code>.forEach()</code> method</h2>
<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach"><code>Array.prototype.forEach()</code></a>
loop allow a more secure iteration, but bring other downsides as:</p>
<ul>
<li>Impossibility to halt the loop with the traditional <code>break;</code> and <code>return;</code> statements.</li>
<li>Array only dedicated method.</li>
</ul>
<h2 id="for-of-to-the-rescue"><a class="markdownIt-Anchor" href="#for-of-to-the-rescue">#</a> <code>for..of</code> to the rescue</h2>
<p>ECMA consortium has so decided to proceed with establishment of a new enhanced version of the <code>for..in</code> loop.
Thus was born the <code>for..of</code> loop which, from now on, will coexist with the previous one allowing to maintain
the backward compatibility with former version of the standard.</p>
<p>The principal is the same : run across any type of <em>iterable object</em>.</p>
<p>In its simplest form, the <code>for..of</code> loop therefore allow to iterate over all values of a table keys.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'hello'</span>, <span class="hljs-string">'world'</span>];
arr.baz = <span class="hljs-string">'and mars'</span>;

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> arrValue <span class="hljs-keyword">of</span> arr ) {
  <span class="hljs-built_in">console</span>.log( arrValue ); <span class="hljs-comment">// 'hello', 'world'</span>
}</code></pre>
<p>The <code>for..of</code> loop can also iterate over more complex types like:</p>
<h3 id="strings"><a class="markdownIt-Anchor" href="#strings">#</a> <em>Strings</em></h3>
<p>In this case, each character is evaluated as a Unicode entity.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">'sm00th'</span>;

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> chr <span class="hljs-keyword">of</span> str ){
  <span class="hljs-built_in">console</span>.log(chr); <span class="hljs-comment">// 's', 'm', '0', '0', 't', 'h'</span>
}</code></pre>
<h3 id="nodelist"><a class="markdownIt-Anchor" href="#nodelist">#</a> <em>NodeList</em></h3>
<pre><code class="language-js"><span class="hljs-comment">// <span class="hljs-doctag">Note:</span> This will only work in platforms that have</span>
<span class="hljs-comment">// implemented NodeList.prototype[Symbol.iterator]</span>

<span class="hljs-comment">// this code add a "read" class to each &lt;p&gt; markup</span>
<span class="hljs-comment">// contained in each &lt;article&gt; markup</span>

<span class="hljs-keyword">const</span> articleParagraphs = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">"article &gt; p"</span>);

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> paragraph <span class="hljs-keyword">of</span> articleParagraphs ) {
  paragraph.classList.add(<span class="hljs-string">"read"</span>);
}</code></pre>
<h3 id="maps"><a class="markdownIt-Anchor" href="#maps">#</a> <em>Maps</em></h3>
<pre><code class="language-js"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([[<span class="hljs-string">'foo'</span>, <span class="hljs-string">'hello'</span>], [<span class="hljs-string">'bar'</span>, <span class="hljs-string">'world'</span>]]);

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> [name, value] <span class="hljs-keyword">of</span> m ) {
  <span class="hljs-built_in">console</span>.log(name + <span class="hljs-string">"-&gt;"</span> + value); <span class="hljs-comment">//"foo-&gt;hello", "bar-&gt;world"</span>
}</code></pre>
<h3 id="sets"><a class="markdownIt-Anchor" href="#sets">#</a> <em>Sets</em></h3>
<pre><code class="language-js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">'foo'</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">42</span>]);

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> s ) {
  <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// 'foo', true, 42</span>
}</code></pre>
<h3 id="generators"><a class="markdownIt-Anchor" href="#generators">#</a> <em>Generators</em></h3>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'foo'</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-number">42</span>;
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'bar'</span>;
}

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> v <span class="hljs-keyword">of</span> foo() ) {
    <span class="hljs-built_in">console</span>.log( v ); <span class="hljs-comment">// 'foo', false, 42, 'bar'</span>
}</code></pre>
<blockquote>
<p>What about traditional object ?</p>
</blockquote>
<p>Suprisingly, objects can’t be directly browsed by this brand new loop.
Fortunately a workaround exists such as
<a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/Object/keys"><code>Object.keys()</code></a></p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> obj = { foo : <span class="hljs-string">'hello'</span>, bar : <span class="hljs-string">'world'</span> };

<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(obj) ) {
  <span class="hljs-built_in">console</span>.log(key + <span class="hljs-string">"-&gt;"</span> + obj[key]); <span class="hljs-comment">// 'foo-&gt;hello', 'bar-&gt;world'</span>
}</code></pre>
<h2 id="in-a-nutshell"><a class="markdownIt-Anchor" href="#in-a-nutshell">#</a> In a nutshell</h2>
<p><code>for..of</code> comes to address <code>for..in</code> loop gaps and allow
a simplified iteration over <em>iterable objects</em> such as:</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String">String</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Maps &amp; WeakMaps</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Sets &amp; WeakSets</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function%2A">Generators</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/NodeList">NodeList</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments">arguments</a></li>
</ul>
<p>Furthermore, <code>for..of</code> as of now resolve pitfalls such as unpredictable iteration order or
automated coercion of index to string.</p>
<h2 id="to-go-further"><a class="markdownIt-Anchor" href="#to-go-further">#</a> To go further</h2>
<p><code>for..of</code> loop is another added arrow to ES6 bow that
allows to run through, in a native way, the brand new <em>iterable objects</em> of the language.</p>
<p>For information about this feature :</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of">MDN Documentation</a></li>
<li><a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/">The post of Jason Orendorff</a></li>
<li><a href="http://tc39wiki.calculist.org/es6/for-of/">The post of Dave Herman</a></li>
<li><a href="http://people.mozilla.org/~jorendorff/es6-draft.html#sec-for-in-and-for-of-statements">ECMA-262 Specification</a></li>
</ul>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/for-of/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/for-of/</guid><pubDate>Wed, 16 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : Arrow functions]]></title><description><![CDATA[<p>ES2015 brings us some new syntax sugar that will likely make you stop using
<code>Function.prototype.bind()</code>.</p>
<p>Arrow functions are just a function shorthand using the <code>=&gt;</code> syntax.</p>
<pre><code class="language-js"><span class="hljs-comment">// es5</span>
<span class="hljs-keyword">var</span> myFn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>
}

<span class="hljs-comment">// es6</span>
<span class="hljs-keyword">const</span> myFn = (x) =&gt; {
  <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>
}</code></pre>
<p>Arrow functions are syntactically similar to the related feature that exists in
other languages like CoffeeScript, Java (8+), C#…</p>
<p>They support both expression and statement bodies.
In our example above, we have seen a classic statement.
But for simple function, we can use an simple expression, to make things shorter.
That means that the previous example can be also written like this:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myFn = (x) =&gt; x + <span class="hljs-number">1</span></code></pre>
<p>Note that when you have only one argument, you can omit parenthesis around it.
So we can also wrote the example like this</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myFn = x =&gt; x + <span class="hljs-number">1</span></code></pre>
<p>And you can also wrap the body in parenthesis if you want to make a multiline expression</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myFn = x =&gt; (
  x +
  <span class="hljs-number">1</span> <span class="hljs-comment">// that can be multilines, you can imagine some JSX here ;)</span>
)</code></pre>
<p>So this examples are all the same :</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myFn = (x) =&gt; {
  <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>
}
<span class="hljs-comment">// ===</span>
<span class="hljs-keyword">const</span> myFn = (x) =&gt; x + <span class="hljs-number">1</span>
<span class="hljs-comment">// ===</span>
<span class="hljs-keyword">const</span> myFn = x =&gt; x + <span class="hljs-number">1</span>
<span class="hljs-comment">// ===</span>
<span class="hljs-keyword">const</span> myFn = x =&gt; (x + <span class="hljs-number">1</span>)</code></pre>
<p>In practice you will use this small functions in method like Array
reduce/filter/map etc.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
<span class="hljs-keyword">const</span> odds = nums.filter(v =&gt; v%<span class="hljs-number">2</span>) <span class="hljs-comment">// [1, 3, 5]</span>
<span class="hljs-keyword">const</span> oddsSum = odds.reduce((sum, v) =&gt; sum+v, <span class="hljs-number">0</span>) <span class="hljs-comment">// 9</span></code></pre>
<h2 id="arrow-functions-don-t-have-a-this"><a class="markdownIt-Anchor" href="#arrow-functions-don-t-have-a-this">#</a> Arrow functions don’t have a <code>this</code></h2>
<p>Yes your read correctly: unlike functions, arrows function share the same lexical this as their surrounding code.
So that means the <code>this</code> you might use use in the body of an arrow function refer to the parent scope:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> Someone = {
  name: “MoOx”,
  friends: [], <span class="hljs-comment">// he got no friends atm :(</span>
  printFriends() {
    <span class="hljs-keyword">this</span>._friends.forEach(f =&gt;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>._name + <span class="hljs-string">" knows "</span> + f)
      <span class="hljs-comment">// `this` is not the function of the forEach !</span>
    )
  }
}</code></pre>
<p>By reading this code, you might understand that you are likely to stop using
<code>bind()</code>:</p>
<pre><code class="language-js">import React, { Component } from “react”
class Stuff extends Component {

  // old way
  onClick(e) {
    this.setState({ omg: false })
  }

  render() {
    return (
      &lt;div&gt;
        { /* old way */ }
        &lt;button onClick={ this.onClick.bind(this) }&gt;
          Old binded call
        &lt;/button&gt;

        { /* LOOK MA', NO BIND ! */ }
        &lt;button onClick={ (e) =&gt; this.onClick(e) }&gt;
          I don’t need `bind` anymore !
        &lt;/button&gt;

        { /* Simpler way */ }
        &lt;button onClick={ (e) =&gt; this.setState({ omg: true }) }&gt;
          Hell yeah
        &lt;/button&gt;
      &lt;/div&gt;
    )
  }
}</code></pre>
<h2 id="note-about-expression-body-and-object"><a class="markdownIt-Anchor" href="#note-about-expression-body-and-object">#</a> Note about expression body and Object</h2>
<p>If you want to return an object you might be surprised to get a syntax error
with this code</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> aFn = (obj) =&gt; {key: obj.value}</code></pre>
<p>Keep in mind that in this context, a brace is to start a statement body, not an
object.
So you will need this</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> aFn = (obj) =&gt; { <span class="hljs-keyword">return</span> {key: obj.value} }</code></pre>
<p>But wait, there is a trick: a stupid couple of parenthesis:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> aFn = (obj) =&gt; ({key: obj.value}) <span class="hljs-comment">// It works !</span></code></pre>
<h2 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion">#</a> Conclusion</h2>
<p>Take a look to the
<a href="https://kangax.github.io/compat-table/es6/#test-arrow_functions">compatibility table</a>.
You will see that arrow functions are already supported by most browsers but you
might need <a href="http://babeljs.io">Babel</a> to use it today.</p>
<p>You will probably use this more and more.
Even if <code>function</code> keyword is not dead, arrow functions <code>=&gt;</code> are probably
going to be a thing !</p>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/arrow-functions/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/arrow-functions/</guid><pubDate>Tue, 15 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : Les fonctions fléchées]]></title><description><![CDATA[<p>ES2015 nous apporte encore du sucre syntaxique qui risque très probablement de
vous faire oublier <code>Function.prototype.bind()</code>.</p>
<p>Les fonctions fléchées offrent une syntaxe raccourcie des fonctions en utilisant
la syntaxe <code>=&gt;</code>.</p>
<pre><code class="language-js"><span class="hljs-comment">// es5</span>
<span class="hljs-keyword">var</span> myFn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
    <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>
}

<span class="hljs-comment">// es6</span>
<span class="hljs-keyword">const</span> myFn = (x) =&gt; {
  <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>
}</code></pre>
<p>Les fonctions fléchées sont syntaxiquement similaire à ce qu’on trouve déjà dans
d’autres langages comme CoffeeScript, Java (8+), C#…</p>
<p>Elles supportent les expressions ou les blocs en tant que corps de fonction.
Dans notre exemple précédent, nous avons utilisé un corps classique.
Pour de simples fonctions, nous pouvons utiliser des expressions, le but étant
d’avoir quelque chose de concis.
Notre exemple précédent peut ainsi s’écrire de la sorte :</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myFn = (x) =&gt; x + <span class="hljs-number">1</span></code></pre>
<p>Notez que lorsque l’on a qu’un argument dans notre fonction, on peut omettre les
parenthèses. Notre exemple peut donc aussi s’écrire ainsi :</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myFn = x =&gt; x + <span class="hljs-number">1</span></code></pre>
<p>Si notre expression mérite d’être sur plusieurs lignes, on peut aussi utiliser des
parenthèses :</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myFn = x =&gt; (
  x +
  <span class="hljs-number">1</span> <span class="hljs-comment">// Ici vous pouvez faire du multi lignes tranquille, on peut imaginer du JSX</span>
)</code></pre>
<p>Les exemples suivants sont donc tous les mêmes :</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myFn = (x) =&gt; {
  <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>
}
<span class="hljs-comment">// ===</span>
<span class="hljs-keyword">const</span> myFn = (x) =&gt; x + <span class="hljs-number">1</span>
<span class="hljs-comment">// ===</span>
<span class="hljs-keyword">const</span> myFn = x =&gt; x + <span class="hljs-number">1</span>
<span class="hljs-comment">// ===</span>
<span class="hljs-keyword">const</span> myFn = x =&gt; (x + <span class="hljs-number">1</span>)</code></pre>
<p>Dans la pratique vous utiliserez souvent cette syntaxe pour des petites méthodes
comme par exemple lors de l’utilisation des fonctions de tableau
reduce/filter/map etc.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
<span class="hljs-keyword">const</span> odds = nums.filter(v =&gt; v%<span class="hljs-number">2</span>) <span class="hljs-comment">// [1, 3, 5]</span>
<span class="hljs-keyword">const</span> oddsSum = odds.reduce((sum, v) =&gt; sum+v, <span class="hljs-number">0</span>) <span class="hljs-comment">// 9</span></code></pre>
<h2 id="les-fonctions-fl-ch-es-n-ont-pas-de-this"><a class="markdownIt-Anchor" href="#les-fonctions-fl-ch-es-n-ont-pas-de-this">#</a> Les fonctions fléchées n’ont pas de <code>this</code></h2>
<p>Oui, vous avez bien lu : à l’inverse des fonctions normales, les fonctions
fléchées partagent le même <code>this</code> lexical que leur scope parent.
Du coup, le <code>this</code> que vous pourrez utiliser dans votre corps de fonction
fléchée est celui du code parent :</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> Someone = {
  name: “MoOx”,
  friends: [], <span class="hljs-comment">// Malheureusement, il n'a pas d'amis :(</span>
  printFriends() {
    <span class="hljs-keyword">this</span>._friends.forEach(f =&gt;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>._name + <span class="hljs-string">" knows "</span> + f)
      <span class="hljs-comment">// `this` ne réfère pas à la fonction fléchée du forEach !</span>
    )
  }
}</code></pre>
<p>En lisant ce code, vous avez peut être compris qu’il peut être possible de ne
plus avoir besoin du <code>bind()</code> aussi souvent que ça pouvait être le cas :</p>
<pre><code class="language-js">import React, { Component } from “react”
class Stuff extends Component {

  // à l'ancienne
  onClick(e) {
    this.setState({ omg: false })
  }

  render() {
    return (
      &lt;div&gt;
        { /* à l'ancienne */ }
        &lt;button onClick={ this.onClick.bind(this) }&gt;
          Old binded call
        &lt;/button&gt;

        { /* REGARDE MAMAN, JE BIND RIEN */ }
        &lt;button onClick={ (e) =&gt; this.onClick(e) }&gt;
          I don’t need `bind` anymore !
        &lt;/button&gt;

        { /* Encore plus simplement */ }
        &lt;button onClick={ (e) =&gt; this.setState({ omg: true }) }&gt;
          Hell yeah
        &lt;/button&gt;
      &lt;/div&gt;
    )
  }
}</code></pre>
<h2 id="note-sur-les-expressions-et-les-objets"><a class="markdownIt-Anchor" href="#note-sur-les-expressions-et-les-objets">#</a> Note sur les expressions et les objets</h2>
<p>Si vous voulez retourner un objet, vous serez surement supris par une erreur de
syntaxe avec ce code :</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> aFn = (obj) =&gt; {key: obj.value}</code></pre>
<p>Gardez en tête que dans ce contexte, une accolade ouvre un corps de fonction,
pas un objet.
Vous devrez donc faire comme ceci :</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> aFn = (obj) =&gt; { <span class="hljs-keyword">return</span> {key: obj.value} }</code></pre>
<p>Mais attendez, avec une simple astuce, on s’en sort avec un couple de
parenthèses :</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> aFn = (obj) =&gt; ({key: obj.value}) <span class="hljs-comment">// It works !</span></code></pre>
<h2 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion">#</a> Conclusion</h2>
<p>Regardez
<a href="https://kangax.github.io/compat-table/es6/#test-arrow_functions">la table de compatibilité</a>.
C’est plutôt bien supporté par la plupart des navigateurs, mais vous risquez
surement d’avoir à utiliser <a href="http://babeljs.io">Babel</a> afin d’être tranquille.</p>
<p>Vous verrez que vous utiliserez les fonctions fléchées de plus en plus.
Même si le mot clé <code>function</code> n’est pas mort, les fonctions fléchées ont un
avenir certain !</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/arrow-functions/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/arrow-functions/</guid><pubDate>Tue, 15 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES2016 (?): fonctions asynchrones (async/await)]]></title><description><![CDATA[<p>Aujourd’hui, une fonctionnalité taggée peut-être abusivement “ES6” puisqu’elle ne
fait pas partie des propositions acceptées cette année : les fonctions asynchrones (async/await).
La <a href="https://tc39.github.io/ecmascript-asyncawait/">spécification</a> est encore au
stade 3 (candidate) à l’heure de cet article. Mais il ne fait plus aucun doute
qu’elle (ou une variante) fera partie de la spécification ES2016.</p>
<h2 id="fonctions-asynchrones"><a class="markdownIt-Anchor" href="#fonctions-asynchrones">#</a> Fonctions asynchrones</h2>
<p>Pour les traitements asynchrones, vous connaissez déjà
<a href="/fr/articles/js/es2015/promises/">les promesses</a> qui ont
évidemment remplacé les callbacks dans votre code. Si vous n’avez pas déjà fait
la bascule vers les promesses (ne serait-ce que pour la propagation d’erreur),
<a href="/fr/articles/js/es2015/generators/">les générateurs</a> ont
du finir de vous convaincre grâce aux <a href="/fr/articles/js/es2015/generators/#use-case-co-routines">coroutines</a>.</p>
<p>Nous allons voir aujourd’hui une nouvelle manière de traiter les fonctions
asynchrones. Mais ne jetez pas vos promesses, tout tourne encore autour d’elles.</p>
<h2 id="exemple-de-traitement-asynchrone-promise"><a class="markdownIt-Anchor" href="#exemple-de-traitement-asynchrone-promise">#</a> Exemple de traitement asynchrone : Promise</h2>
<p>Partons du programme suivant exécuté le
6 décembre dernier dont l’API est basée sur les promesses :</p>
<ul>
<li>Il récupère tous les utilisateurs prénommés Nicolas</li>
<li>Il envoie un mail à chacun pour souhaiter bonne fête</li>
</ul>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendEmails</span> (<span class="hljs-params">query</span>) </span>{
  <span class="hljs-keyword">const</span> usersP = getUsers({firstName: <span class="hljs-string">'Nicolas'</span>})
  <span class="hljs-comment">// On récupère le champ "email" de tous les utilisateurs</span>
  <span class="hljs-keyword">const</span> emailsP = usersP.then((users) =&gt; users.map(u =&gt; u.email))
  <span class="hljs-comment">// Pour chaque email…</span>
  <span class="hljs-keyword">const</span> sentP = emailsP.then((emails) =&gt; emails.map((email) =&gt; {
    <span class="hljs-comment">// … on envoie un mail</span>
    <span class="hljs-keyword">return</span> sendMail(email, <span class="hljs-string">'Bonne fête'</span>)
  }))
  <span class="hljs-comment">// On attend que tous les envois soient résolus</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(sentP)
}

sendEmails({ firstName: <span class="hljs-string">'Nicolas'</span> })
  .then(() =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'OK'</span>))
  .catch(() =&gt; <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'FAIL'</span>))</code></pre>
<h2 id="nouveaux-mot-cl-s-async-et-await"><a class="markdownIt-Anchor" href="#nouveaux-mot-cl-s-async-et-await">#</a> Nouveaux mot-clés <code>async</code> et <code>await</code></h2>
<p>Une fonction peut être marquée comme asynchrone lorsque préfixée par <code>async</code> :</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// …</span>
}</code></pre>
<p>Dans une fonction asynchrone, et <strong>seulement</strong> dans une fonction asynchrone, le
mot-clé <code>await</code> devient disponible. Lorsqu’il est utilisé en préfixe d’une
promesse, l’évaluation de l’expression est “mise en pause” jusqu’à la résolution
(ou le rejet) de la promesse :</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">await</span> aPromise
  <span class="hljs-comment">// on n'arrivera à cette ligne que lorsque "aPromise" sera résolue</span>
}</code></pre>
<p>Évidemment, l’expression a alors pour valeur celle de résolution de la
promesse, et en cas d’erreur l’expression va lever (<code>throw</code>) une erreur :</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> aPromise
    <span class="hljs-comment">// Ici "aPromise" est résolue avec la valeur "result"</span>
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-comment">// Ici "aPromise" est rejetée avec l'erreur "err"</span>
  }

  <span class="hljs-keyword">return</span> <span class="hljs-number">42</span> <span class="hljs-comment">// cette ligne n'est atteinte qu'après résolution/rejet</span>
}</code></pre>
<p>Concrètement, si vous vous souvenez de l’article sur les générateurs et de la
partie sur les coroutines, remplacez <code>async function</code> par <code>function *</code> et
<code>await</code> par <code>yield</code>, et vous avez compris le principe. ;)</p>
<h2 id="notre-premier-exemple-avec-les-fonctions-asynchrones"><a class="markdownIt-Anchor" href="#notre-premier-exemple-avec-les-fonctions-asynchrones">#</a> Notre premier exemple, avec les fonctions asynchrones</h2>
<p>Réécrivons notre premier exemple avec des fonctions asynchrones :</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendEmails</span> (<span class="hljs-params">query</span>) </span>{
  <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> getUsers({firstName: <span class="hljs-string">'Nicolas'</span>})
  <span class="hljs-keyword">const</span> emails = users.map(u =&gt; u.email)
  <span class="hljs-keyword">const</span> sentP = emails.map((email) =&gt; sendMail(email, <span class="hljs-string">'Bonne fête'</span>))
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(sentP)
}

<span class="hljs-comment">// Attention, on ne peut pas utiliser "await" hors d'une fonction "async"</span>
<span class="hljs-comment">// il faut donc "wrapper" notre code autour d'une fonction asynchrone</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> sendEmails({ firstName: <span class="hljs-string">'Nicolas'</span> })
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'OK'</span>)
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'FAIL'</span>)
  }
}

main()</code></pre>
<p>Mieux ? Moins bien ? Question de goût, mais on retrouve un code impératif plus
habituel.</p>
<h2 id="attention-au-pi-ge-de-l-ex-cution-en-s-rie"><a class="markdownIt-Anchor" href="#attention-au-pi-ge-de-l-ex-cution-en-s-rie">#</a> Attention au piège de l’exécution en série !</h2>
<p>Prenons l’exemple de requêtes qu’on exécute en concurrence avant d’utiliser
leurs résultats :</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> xP = getX() <span class="hljs-comment">// Requête Ajax</span>
<span class="hljs-keyword">const</span> yP = getY() <span class="hljs-comment">// Requête BDD</span>
<span class="hljs-keyword">const</span> resultP = <span class="hljs-built_in">Promise</span>.all([xP, yP]).then(sum)</code></pre>
<p>Dans cet exemple, les requêtes sont lancées, exécutées en parallèle puis leurs
retours attendus avant de passer à la suite.</p>
<p>Si on le traduit bêtement ainsi, on perd l’aspect concurrentiel :</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> x = <span class="hljs-keyword">await</span> getX() <span class="hljs-comment">// Requête Ajax…</span>
<span class="hljs-comment">// … requête terminée !</span>
<span class="hljs-keyword">const</span> y = <span class="hljs-keyword">await</span> getY() <span class="hljs-comment">// Requête BDD…</span>
<span class="hljs-comment">// … requête terminée !</span>
<span class="hljs-keyword">const</span> result = sum([x, y])</code></pre>
<p>Il faudra bien distinguer le moment où on souhaite <strong>démarrer l’action</strong> et le
moment où l’on souhaite <strong>disposer de son résultat</strong>, il y a plusieurs manières
de résoudre le problème, qui dépendent essentiellement du goût du développeur ;)</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> xP = getX() <span class="hljs-comment">// Requête Ajax démarrée…</span>
<span class="hljs-keyword">const</span> yP = getY() <span class="hljs-comment">// Requête BDD démarrée…</span>

<span class="hljs-comment">// Version 1 :</span>
<span class="hljs-keyword">const</span> x = <span class="hljs-keyword">await</span> xP <span class="hljs-comment">// …requête Ajax terminée !</span>
<span class="hljs-keyword">const</span> y = <span class="hljs-keyword">await</span> yP <span class="hljs-comment">// …requête BDD terminée !</span>
<span class="hljs-keyword">const</span> result = sum([x, y])

<span class="hljs-comment">// Version 2 avec un tableau :</span>
<span class="hljs-keyword">const</span> vars = [<span class="hljs-keyword">await</span> xP, <span class="hljs-keyword">await</span> yP]
<span class="hljs-keyword">const</span> result = sum(vars)

<span class="hljs-comment">// Version 3 avec Promise.all :</span>
<span class="hljs-keyword">const</span> vars = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([xP, yP])
<span class="hljs-keyword">const</span> result = sum(vars)</code></pre>
<h2 id="et-aujourd-hui"><a class="markdownIt-Anchor" href="#et-aujourd-hui">#</a> Et aujourd’hui ?</h2>
<p>On peut utiliser Babel pour compiler son code utilisant <code>async/await</code> en un
code basé sur les générateurs : il vous suffira d’ajouter les plugins Babel
<code>syntax-async-functions</code> et <code>transform-async-to-generator</code> (attention à
inclure <code>babel-polyfill</code> en fichier d’entrée).</p>
<h2 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion">#</a> Conclusion</h2>
<p>Grâce aux fonctions asynchrones, la refactorisation d’un code bloquant vers un
code non bloquant devient vraiment aisée. Les promesses simplifiaient déjà le
processus mais on n’était pas débarassé des callbacks. Là, à deux mot-clés près
c’est exactement la même chose !</p>
<p>D’un certain côté, c’est un retour en arrière : l’asynchrone mène aux promesses,
qui mène à la programmation fonctionnelle, qui apporte tant de bienfaits… Il
s’agira de trouver le bon équilibre, je ne suis pas convaincu d’abandonner mes
<code>.then</code> tout de suite, mais il est certain que c’est une véritable avancée
pour ce langage : la courbe d’apprentissage des traitements asynchrones va être
drastiquement aplanie ;)</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2016/async-await/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2016/async-await/</guid><pubDate>Mon, 14 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : les nouvelles méthode d'Array]]></title><description><![CDATA[<p><s>ES6</s>  ES2015 enrichit les objets de la bibiliothèque standard de nouvelles fonctionnalités.
Voici les nouveautés que l’on va trouver dans <code>Array</code>.</p>
<h2 id="array-from"><a class="markdownIt-Anchor" href="#array-from">#</a> Array.from()</h2>
<p>Parmi les nouvelles méthodes ajoutées à Array, <code>Array.from()</code> est peut être celle que vous allez utiliser le plus souvent. Elle va nous permettre de créer un tableau à partir d’un itérable ou d’un objet qui ressemble à un tableau comme une NodeList, ou encore <code>arguments</code>.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> nodes = <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">document</span>.querySeletorAll(<span class="hljs-string">'div'</span>))
nodes.forEach(node =&gt; <span class="hljs-built_in">console</span>.log(node))</code></pre>
<h2 id="array-of"><a class="markdownIt-Anchor" href="#array-of">#</a> Array.of()</h2>
<p>Cette méthode va permettre de créer un tableau à partir des arguments reçus.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>.of(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>)
<span class="hljs-built_in">console</span>.log(arr.join(<span class="hljs-string">" "</span>)) <span class="hljs-comment">// "hello world"</span></code></pre>
<h2 id="array-prototype-keys-array-prototype-entries"><a class="markdownIt-Anchor" href="#array-prototype-keys-array-prototype-entries">#</a> Array.prototype.keys() &amp; Array.prototype.entries()</h2>
<p>On retrouve aussi ces méthodes sur d’autres itérables comme Map ou Set.
<code>Array.prototype.keys()</code> va renvoyer un nouveau tableau dont les valeurs seront les clefs du tableau passé en paramètre :</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> arr =  [...Array(<span class="hljs-number">3</span>).keys()]
<span class="hljs-built_in">console</span>.log(arr) <span class="hljs-comment">// [0,1,2]</span></code></pre>
<p><code>Array.prototype.entries()</code> quant à lui va renvoyer un tableau composé des paires clé/valeur :</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>]
<span class="hljs-built_in">console</span>.log(arr.entries()) <span class="hljs-comment">// [[0, "hello"], [1, "world"]]</span></code></pre>
<h2 id="array-prototype-find"><a class="markdownIt-Anchor" href="#array-prototype-find">#</a> Array.prototype.find()</h2>
<p>Cette méthode va permettre de renvoyer une valeur contenue dans le tableau si celle-ci vérifie
la condition définie par la fonction de prédicat passée en paramètre. On retrouve le même principe qu’avec <code>filter</code>, <code>some</code> et <code>every</code>. Si aucune valeur ne
valide la fonction de prédicat, alors la méthode renverra <code>undefined</code>.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> arr = [{id:<span class="hljs-number">1</span>, label:<span class="hljs-string">"hello"</span>}, {id:<span class="hljs-number">2</span>, name: <span class="hljs-string">"world"</span>}]
<span class="hljs-keyword">const</span> found = arr.find(item =&gt; item.id === <span class="hljs-number">2</span>)
<span class="hljs-keyword">const</span> notfound = arr.find(item =&gt; item.id === <span class="hljs-number">3</span>)
<span class="hljs-built_in">console</span>.log(found, notfound) <span class="hljs-comment">// {id:2, name: "worl"}, undefined</span></code></pre>
<p>À noter qu’il existe aussi <code>Array.prototype.findIndex()</code> qui renverra non pas l’objet, mais l’index de l’objet qui validera la fonction de prédicat.</p>
<h2 id="array-prototype-fill"><a class="markdownIt-Anchor" href="#array-prototype-fill">#</a> Array.prototype.fill()</h2>
<p>Cette méthode va permettre de remplir un tableau avec une valeur passée en paramètre. Il est toutefois possible de définir un index de début et un index de fin (comme avec slice par exemple) si l’on souhaite remplacer qu’une partie du tableau.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> arr = <span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>).fill(<span class="hljs-number">1</span>)
<span class="hljs-built_in">console</span>.log(arr) <span class="hljs-comment">// [1,1,1]</span></code></pre>
<h2 id="array-prototype-copywithin"><a class="markdownIt-Anchor" href="#array-prototype-copywithin">#</a> Array.prototype.copyWithin()</h2>
<p>Cette méthode va permettre de renvoyer un nouveau tableau en remplaçant une partie du tableau par une séquence de ce dernier. Pour cela on va indiquer à partir de quel index on souhaite démarrer la copie de la sequence, ainsi que l’index de début et de fin de la séquence que l’on souhaite voir répéter.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"hello"</span>,<span class="hljs-string">"alice"</span>, <span class="hljs-string">"my"</span>, <span class="hljs-string">"name"</span>, <span class="hljs-string">"is"</span> <span class="hljs-string">"bob"</span>]
<span class="hljs-built_in">console</span>.log(arr.copyWithin(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)]) <span class="hljs-comment">//  "hello","bob", "my", "name", "is" "bob"]</span></code></pre>
<p>Certaines méthodes ne paraissent pas forcément super utiles alors n’hésitez à utiliser les commentaires pour partager des exemples d’utilisation plus intéressants :p</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/array-methods-addition/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/array-methods-addition/</guid><pubDate>Sun, 13 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : paramètres rest et opérateur spread]]></title><description><![CDATA[<p>Identiques en apparence et en syntaxe, ils permettent d’effectuer plus
simplement des opérations complexes sur les tableaux, ou tout autre objet
itérable.</p>
<h2 id="les-param-tres-rest"><a class="markdownIt-Anchor" href="#les-param-tres-rest">#</a> Les paramètres rest</h2>
<p>Avez-vous déjà eu l’occasion d’utiliser l’horrible variable magique <code>arguments</code> ?
Disponible au sein de chaque fonction, elle permet d’en récupérer, comme son
nom l’indique, les arguments. Si l’objet récupéré est similaire à un <code>Array</code>,
il ne dispose d’aucune des propriétés ou des méthodes de celui-ci, à
l’exception de <code>length</code>.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params">separator</span>) </span>{
  <span class="hljs-comment">// conversion nécessaire en objet de type Array</span>
  <span class="hljs-keyword">var</span> words = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>)
  <span class="hljs-keyword">return</span> words.join(separator)
}

myFunction(<span class="hljs-string">"-"</span>, <span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>) <span class="hljs-comment">// "foo-bar"</span></code></pre>
<p>Les paramètres rest vous permettent de récupérer un véritable <code>Array</code> à l’aide
du simple préfixe <code>...</code> appliqué sur le <strong>dernier</strong> argument de votre fonction.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params">separator, ...words</span>) </span>{
  <span class="hljs-keyword">return</span> words.join(separator)
}

myFunction(<span class="hljs-string">"-"</span>, <span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>) <span class="hljs-comment">// "foo-bar"</span></code></pre>
<p>Il vous sera en revanche impossible de lui attribuer une <a href="/fr/articles/js/es2015/defaults/">valeur par défaut</a>.</p>
<h2 id="l-op-rateur-spread"><a class="markdownIt-Anchor" href="#l-op-rateur-spread">#</a> L’opérateur spread</h2>
<p>Aussi appelé opérateur de décomposition, il permet de développer un objet
itérable (comme un <code>Array</code>) lorsqu’on a besoin de plusieurs arguments.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myArray = [<span class="hljs-number">1991</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>]
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(...myArray) <span class="hljs-comment">// object Date - équivaut à: new Date(1991, 8, 1)</span>

<span class="hljs-keyword">const</span> myString = <span class="hljs-string">"foo bar"</span>
<span class="hljs-comment">// les objets String étant itérables</span>
[...myString] <span class="hljs-comment">// ["f", "o", "o", " ", "b", "a", "r"]</span></code></pre>
<p>À noter que contrairement aux paramètres rest, l’opérateur spread peut être
mélangé aux autres arguments d’une fonction.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> myArray = [<span class="hljs-number">8</span>, <span class="hljs-number">1</span>]
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">1991</span>, ...myArray, <span class="hljs-number">12</span>) <span class="hljs-comment">// object Date - équivaut à: new Date(1991, 8, 1, 12)</span></code></pre>
<p>Les possibilités offertes par cette nouveauté sont très nombreuses. Voici
quelques usages un peu plus avancés pour stimuler votre inspiration :</p>
<h4 id="viter-l-utilisation-de-apply"><a class="markdownIt-Anchor" href="#viter-l-utilisation-de-apply">#</a> Éviter l’utilisation de .apply()</h4>
<pre><code class="language-js"><span class="hljs-comment">// ES5</span>
<span class="hljs-built_in">console</span>.log.apply(<span class="hljs-built_in">console</span>, [<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>])

<span class="hljs-comment">// ES6 / ES2015</span>
<span class="hljs-built_in">console</span>.log(...[<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>]) <span class="hljs-comment">// même résultat</span></code></pre>
<h4 id="concat-ner-plusieurs-it-rables"><a class="markdownIt-Anchor" href="#concat-ner-plusieurs-it-rables">#</a> Concaténer plusieurs itérables</h4>
<pre><code class="language-js"><span class="hljs-keyword">const</span> stronglyTyped = [<span class="hljs-string">"scala"</span>, <span class="hljs-string">"haskell"</span>]

<span class="hljs-comment">// ES5</span>
[<span class="hljs-string">"go"</span>, <span class="hljs-string">"rust"</span>].concat(stronglyTyped) <span class="hljs-comment">// ["go", "rust", "scala", "haskell"]</span>

<span class="hljs-comment">// ES6 / ES2015</span>
[<span class="hljs-string">"go"</span>, <span class="hljs-string">"rust"</span>, ...stronglyTyped] <span class="hljs-comment">// ["go", "rust", "scala", "haskell"]</span></code></pre>
<h4 id="d-structurer-dans-un-tableau"><a class="markdownIt-Anchor" href="#d-structurer-dans-un-tableau">#</a> Déstructurer dans un tableau</h4>
<p>Si vous n’avez pas encore connaissance des possibilités offertes par le
destructuring, je vous invite à lire ce <a href="/fr/articles/js/es2015/destructuring/">précédent article</a>.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> words = [<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>, <span class="hljs-string">"baz"</span>]

<span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">const</span> first = words[<span class="hljs-number">0</span>] <span class="hljs-comment">// "foo"</span>
<span class="hljs-keyword">const</span> rest = words.slice(<span class="hljs-number">1</span>) <span class="hljs-comment">// ["bar", "baz"]</span>

<span class="hljs-comment">// ES6 / ES2015</span>
<span class="hljs-keyword">const</span> [first, ...rest] = words <span class="hljs-comment">// même résulat</span></code></pre>
<h4 id="it-rer-sur-le-r-sultat-d-un-queryselectorall"><a class="markdownIt-Anchor" href="#it-rer-sur-le-r-sultat-d-un-queryselectorall">#</a> Itérer sur le résultat d’un .querySelectorAll()</h4>
<pre><code class="language-js">[...document.querySelectorAll(<span class="hljs-string">'div'</span>)] <span class="hljs-comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></code></pre>
<h2 id="en-r-sum"><a class="markdownIt-Anchor" href="#en-r-sum">#</a> En résumé</h2>
<p>Comme vous avez pu le constater par vous-même, les cas d’utilisation des
paramètres rest et de l’opérateur spread sont légion.</p>
<p><a href="http://kangax.github.io/compat-table/es6/#spread_(...)_operator">Gérés</a>
correctement par Babel et Traceur, ils vous permettront de rendre votre code
plus concis en évitant bien souvent l’écriture de boucles inutiles.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/rest-spread/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/rest-spread/</guid><pubDate>Sat, 12 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : les Maps & WeakMaps]]></title><description><![CDATA[<h2 id="maps"><a class="markdownIt-Anchor" href="#maps">#</a> Maps</h2>
<p>Comme les objets, les maps et weak maps introduites avec ES6 sont des dictionnaires. La différence avec un objet, c’est que n’importe quelle valeur peut être utilisée comme clé.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()
myMap.set(<span class="hljs-built_in">window</span>, <span class="hljs-number">1</span>)
myMap.get(<span class="hljs-built_in">window</span>) <span class="hljs-comment">// 1</span></code></pre>
<p>Pour créer une map avec des valeurs, on peut passer un tableau de clés/valeurs en argument :</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([
  [ <span class="hljs-number">1</span>, <span class="hljs-string">"foo"</span> ],
  [ <span class="hljs-built_in">window</span>, <span class="hljs-string">"bar"</span> ],
])</code></pre>
<p>Pour tester si une clé est présente, on peut utiliser la méthode <code>has</code> :</p>
<pre><code class="language-javascript">map.has(<span class="hljs-number">1</span>) <span class="hljs-comment">// false</span></code></pre>
<p>On peut itérer sur les entrées d’une map à l’aide de <code>forEach</code> :</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> myMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([
  [ <span class="hljs-number">1</span>, <span class="hljs-string">"foo"</span> ],
  [ <span class="hljs-built_in">window</span>, <span class="hljs-string">"bar"</span> ],
])

myMap.forEach((value, key) =&gt; {
	<span class="hljs-comment">// do something</span>
})</code></pre>
<p>On peut aussi itérer à l’aide du <code>for … of</code> :</p>
<pre><code class="language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> myMap) {
  <span class="hljs-built_in">console</span>.log(key, value)
}</code></pre>
<p>Ainsi que convertir la map en tableau à l’aide du spread, puisqu’une map est itérable :</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> myEntries = [...myMap] <span class="hljs-comment">// […[key, value]]</span>
<span class="hljs-keyword">const</span> myEntries = [...myMap.entries()] <span class="hljs-comment">// alternativement</span></code></pre>
<p>On peut aussi récupérer des itérables par clés et valeurs :</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> myKeys = [...myMap.keys()]
<span class="hljs-keyword">const</span> myValues = [...myMap.values()]</code></pre>
<p>Particularité, la valeur <code>NaN</code>, qui en JS n’est pas égale à elle même, est bien gérée :</p>
<pre><code class="language-javascript">myMap.set(<span class="hljs-literal">NaN</span>, <span class="hljs-number">1</span>)
myMap.get(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// 1</span></code></pre>
<p>Une utilisation possible des Maps est la fonction <code>dedupe</code> pour éliminer les doublons d’un array :</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> dedupe = (array) =&gt; {
  <span class="hljs-keyword">return</span> [...new <span class="hljs-built_in">Map</span>(array.map((item) =&gt; [item, <span class="hljs-literal">true</span>])).keys()]
}

dedupe([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>]) <span class="hljs-comment">// [1, 2, 3, 4]</span></code></pre>
<h2 id="weakmaps"><a class="markdownIt-Anchor" href="#weakmaps">#</a> WeakMaps</h2>
<p>Les WeakMaps sont comme les Maps mais qui ne gardent pas les valeurs “oubliées”. Le garbage collector ne tient donc pas compte des weak maps.</p>
<p>Les WeakMaps ne possèdent pas de méthodes d’itération et n’acceptent pas de valeurs primitives comme clés.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> myWeakMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()
myWeakMap.set(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// TypeError</span></code></pre>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> myWeakMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()
myWeakMap.set(<span class="hljs-built_in">window</span>, <span class="hljs-number">1</span>)
(() =&gt; {
  <span class="hljs-keyword">const</span> object = {}
  myWeakMap.set(object, <span class="hljs-number">2</span>)
})()
<span class="hljs-comment">// myWeakMap a oublié la valeur 2, car `object` n'est plus accessible</span>
<span class="hljs-comment">// seule la clé `window` persiste.</span></code></pre>
<p>Un usage possible est le stockage d’informations lié à une instance de classe, permettant de “cacher” cette information de l’instance :</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> callbacks = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleEventEmitter</span> </span>{
  constructor() {
    callbacks.set(<span class="hljs-keyword">this</span>, [])
  }
  addEventListener(callback) {
    callbacks.set(<span class="hljs-keyword">this</span>, callbacks.get(<span class="hljs-keyword">this</span>).concat(callback))
  }
  removeEventListener(callback) {
    callbacks.set(<span class="hljs-keyword">this</span>, callbacks.get(<span class="hljs-keyword">this</span>)
      .filter((func) =&gt; func !== callback))
  }
  triggerEvent(...args) {
    callbacks.get(<span class="hljs-keyword">this</span>).forEach((func) =&gt; func(...args))
  }
}</code></pre>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/maps-weakmaps/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/maps-weakmaps/</guid><pubDate>Fri, 11 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : iterators and generators]]></title><description><![CDATA[<p>ES2015 brings a lot of syntax sugar but not a lot of new real features.
Generators are a new feature to generate iterators that follow the
<a href="/en/articles/js/es2015/iterators/">iterator protocol</a>.
They allow to take control of the execution of a function from the outside.</p>
<h2 id="idle-function"><a class="markdownIt-Anchor" href="#idle-function">#</a> Idle function</h2>
<p>A function followed by an asterisk (<code>function*</code>) is never executed directly
and instead calling it will return an iterator.
A generator is able to pause itself (and will do that by default).
It’s also capable of continue where it was paused: the iterator returned is an
object that contains a <code>next</code> method which allows (when you call it) to
continue the execution of the generator where it was paused.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">idleFunction</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'World'</span>)
}

<span class="hljs-keyword">const</span> iterator = idleFunction()
<span class="hljs-comment">// The execution is paused, and is waiting to be continued</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello'</span>)
iterator.next() <span class="hljs-comment">// The execution will now continue and will log "World"</span></code></pre>
<p>Note that this is not <strong>blocking</strong> code: the function is paused, the execution
can continue later, but meanwhile, the <em>event-loop</em> is still running.</p>
<h2 id="emitting-new-values-with-yield"><a class="markdownIt-Anchor" href="#emitting-new-values-with-yield">#</a> Emitting new values with <code>yield</code></h2>
<p>Following the <a href="/en/articles/js/es2015/iterators/">iterator protocol</a>, the
<code>next()</code> method will returns an object with 2 properties :</p>
<ul>
<li><code>done</code> is equal to <code>true</code> when generator has finished its job exécution</li>
<li><code>value</code> is the value emitted by the generator when it become idle</li>
</ul>
<p>How to emit a value ? The keyword <code>yield</code> is made for this:
it will returns a value and idle the execution of the function.
The thing is: you are going to use yield multiple times in the same function.
Otherwise a generator does not make sense, and a simple function with <code>return</code>
is enough.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">numbers</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
}

<span class="hljs-keyword">const</span> iterator = numbers()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
iterator.next() <span class="hljs-comment">// { value: 2, done: false }</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<p>Note: if our generator <code>return</code>s a value, it will be affected to the <code>value</code>
of the last iteration.</p>
<h3 id="use-case-infinite-lists"><a class="markdownIt-Anchor" href="#use-case-infinite-lists">#</a> <em>Use case</em> : infinite lists</h3>
<p>At this stage, the first interesting use case is to handle an infinite list.
We can loop on a list that do not have a precise length.
Here is an example with the Fibonacci sequence to get all results lower than
100 :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">fibo</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> [a, b] = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) { <span class="hljs-comment">// Who can stop me?</span>
    [a, b] = [b, a + b]
    <span class="hljs-keyword">yield</span> a
  }
}

<span class="hljs-keyword">const</span> iterator = fibo()
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> iterator) {
  <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">100</span>) {
    <span class="hljs-keyword">break</span> <span class="hljs-comment">// *I* can stop you</span>
  }
  <span class="hljs-built_in">console</span>.log(n)
}
<span class="hljs-comment">// 1 2 3 5 8 13 21 34 55 89</span></code></pre>
<p>Note : The <code>for … of</code> will be explained in another article.</p>
<h2 id="sending-value-to-the-generator"><a class="markdownIt-Anchor" href="#sending-value-to-the-generator">#</a> Sending value to the generator</h2>
<p>We have seen that <code>yield</code> allows to emit a value from the generator.
The opposite is possible too : <code>next</code> accepts a value that will be returned by
<code>yield</code> :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">math</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// the first next() will "start" the generator</span>
  <span class="hljs-keyword">const</span> x = <span class="hljs-keyword">yield</span> <span class="hljs-comment">// the first value will be undefined</span>
  <span class="hljs-comment">// x = the argument of the other next() call</span>
  <span class="hljs-keyword">const</span> y = <span class="hljs-keyword">yield</span> x + <span class="hljs-number">1</span> <span class="hljs-comment">// value of the second iteration : x + 1</span>
  <span class="hljs-comment">// y = third call of next()</span>
  <span class="hljs-keyword">yield</span> y <span class="hljs-comment">// value of the last iteration : y</span>
  <span class="hljs-comment">// the fourth call and the others will return { value: undefined, done: true }</span>
}

<span class="hljs-keyword">const</span> iterator = math()
iterator.next(<span class="hljs-number">42</span>) <span class="hljs-comment">// { value: undefined, done: false }</span>
<span class="hljs-comment">// Passer un paramètre au premier appel à next() n'est pas utile : cette valeur</span>
<span class="hljs-comment">// n'est pas accessible dans le générateur car aucun "yield" correspondant</span>

iterator.next(<span class="hljs-number">33</span>) <span class="hljs-comment">// { value: 34, done: false }, x = 33 dans le générateur</span>
iterator.next(<span class="hljs-number">27</span>) <span class="hljs-comment">// { value: 27, done: false }, y = 27 dans le générateur</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<p>This might sound not really useful, but keep in mind that you can send any type
of data to <code>next()</code> : a function, an object, another iterator…
Possiblities are limitless ! Let’s take a look to an example using promises.</p>
<h3 id="use-case-co-routines"><a class="markdownIt-Anchor" href="#use-case-co-routines">#</a> <em>Use case</em> : co-routines</h3>
<p>The code of the generator itself cannot be async: call to <code>yield</code> follow each
others synchronously.
The main controller can still be free to call <code>next()</code> when it wants to.</p>
<p>So we have functions that we can play and pause whenever we want.
What if our generator emitted a promise? In order to tell when it’s time to
continue.
What if the controller, when it knows it got a promise wait for it to be
resolved in order to send back the value to the generator?
This way, the generator will be able to run synchronous code in an non blocking
way when handling async operations :</p>
<pre><code class="language-js">execAsync(<span class="hljs-function"><span class="hljs-keyword">function</span> * (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Ajax request…"</span>)
  <span class="hljs-keyword">var</span> rows = <span class="hljs-keyword">yield</span> fetch(<span class="hljs-string">"http://my.api/get"</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Work…"</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Save…"</span>)
  <span class="hljs-keyword">yield</span> fetch(<span class="hljs-string">"http://my.api/post"</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"OK."</span>)
}) <span class="hljs-comment">// Ajax request… Work… Save… OK.</span></code></pre>
<p>How cool is that? This is clearly the most interesting use case for us and is
actually pretty simple :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execAsync</span> (<span class="hljs-params">promiseGenerator</span>) </span>{
  <span class="hljs-keyword">const</span> iter = promiseGenerator() <span class="hljs-comment">// pause…</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loop</span> (<span class="hljs-params">iteration</span>) </span>{
    <span class="hljs-keyword">if</span> (iteration.done) { <span class="hljs-comment">// That's the part to detect the last return</span>
      <span class="hljs-keyword">return</span> iteration.value
    }

    <span class="hljs-comment">// this is a generator of promise, we we wait for the resolution</span>
    <span class="hljs-keyword">return</span> iteration.value.then(result =&gt; {
      <span class="hljs-comment">// promise is resolved so we can send back the value to the generator</span>
      <span class="hljs-keyword">const</span> nextIteration = iter.next(result) <span class="hljs-comment">// this value is returned by the</span>
      <span class="hljs-comment">// same "yield" which emitted the promise, how convenient is that?</span>

      <span class="hljs-comment">// NE<span class="hljs-label">XXXTTTT</span></span>
      <span class="hljs-keyword">return</span> next(nextIteration)
    })
  }

  <span class="hljs-keyword">const</span> promiseIteration = iter.next()
  <span class="hljs-comment">// we continue the execution until the next "yield"</span>
  <span class="hljs-comment">// the generator will be paused again until the next call to "iter.next"</span>

  <span class="hljs-comment">// We run the first iteration it and return it</span>
  <span class="hljs-keyword">return</span> loop(promiseIteration)
}</code></pre>
<h2 id="more-more-more"><a class="markdownIt-Anchor" href="#more-more-more">#</a> More! more! more!</h2>
<h3 id="error-handling"><a class="markdownIt-Anchor" href="#error-handling">#</a> Error handling</h3>
<p>Errors, like everything, can be emitted in both directions.
The generator can <code>throw</code> (the code is synchronous) :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">fail</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'oops'</span>)
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
}

<span class="hljs-keyword">const</span> iterator = fail()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
<span class="hljs-keyword">try</span> {
  iterator.next() <span class="hljs-comment">// throws</span>
} <span class="hljs-keyword">catch</span> (e) {
  e <span class="hljs-comment">// Error('oops')</span>
}</code></pre>
<p>The controller can also emit an error inside with the <code>throw</code> method of the
iterator :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">fail</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-built_in">console</span>.error(e)
  }
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
}

<span class="hljs-keyword">const</span> iterator = fail()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
iterator.throw(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"nope"</span>)) <span class="hljs-comment">// "[Error: nope]"</span>
iterator.next() <span class="hljs-comment">// { value: 2, done: false }</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<p>Note: you need to keep in mind that the first <code>next</code> is used to unlock
the execution of the generator, until the first <code>yield</code>, evaluate the emitted
expression, and send it in the <code>next()</code>, and pause the function.
That’s the second <code>yield</code> that will continue <strong>from the <code>yield 1</code></strong>.
This is a part not really intuitive that can be hard to understand.</p>
<h3 id="delegation"><a class="markdownIt-Anchor" href="#delegation">#</a> Delegation</h3>
<p>The <code>yield*</code> operator allow to emit value from another iterator :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">oneToThree</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">zeroToFour</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">0</span>
  <span class="hljs-keyword">yield</span> * oneToThree()
  <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span>
}</code></pre>
<p>That works with all <a href="/en/articles/js/es2015/iterators/"><em>iterables</em></a> :
for example <code>yield * [1, 2, 3]</code> is valid.</p>
<h3 id="anticipated-return"><a class="markdownIt-Anchor" href="#anticipated-return">#</a> Anticipated return</h3>
<p>It’s possible to end an operation of a generator from the controller using the
<code>return</code> method of the iterator.
Everything will happen like if the generator was ending immediately with the
returned value.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">numbers</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>
}

<span class="hljs-keyword">const</span> iterator = numbers()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
iterator.return(<span class="hljs-number">4</span>) <span class="hljs-comment">// { value: 4, done: true } → yield 2 and yield 3 are skipped</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<h2 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion">#</a> Conclusion</h2>
<p>Take a look to the
<a href="https://kangax.github.io/compat-table/es6/#test-generators">compatibility table</a>.</p>
<p>Generators bring us a new bundle of feature that allow us to inverse
responsibility : the code that calling the generator can take over the way the
called function will be executed.
They represent a new concept that will probably really change the way we will
code in the incoming months/years :
async function, observables… take their roots in generators.
Understanding generators will helps you to work with those other new features.</p>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/generators/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/generators/</guid><pubDate>Thu, 10 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : itérateurs et générateurs]]></title><description><![CDATA[<p>Un gros morceau aujourd’hui : les itérateurs et les fonctions qui les génèrent,
appelées “générateurs”.
ES6/2015 apporte énormément de “sucres syntaxiques”, même s’ils sont
terriblement pratiques. Les valeurs par défaut, l’affectation par
déstructuration, les fonctions flêchées…
Tout ça n’apporte pas de réelle nouvelle fonctionnalité.
C’est un peu différent pour les générateurs qui vont permettre de prendre le
contrôle sur l’éxécution d’une fonction depuis l’extérieur.</p>
<h2 id="fonction-en-pause"><a class="markdownIt-Anchor" href="#fonction-en-pause">#</a> Fonction “en pause”</h2>
<p>Un nouveau mot-clé fait son apparition : <code>function*</code>, une fonction marquée par
l’astérisque n’est jamais exécutée directement, à la place, elle retourne un
<em>itérateur</em>. Un générateur est donc capable de s’interrompre (d’ailleurs, il
l’est par défaut).
Il est également capable de reprendre là où il s’était arrêté :
l’itérateur retourné est un objet exposant une méthode  <code>next</code> qui
lorsqu’elle est appelée demande au générateur de reprendre là où il en était.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">idleFunction</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'World'</span>)
}

<span class="hljs-keyword">const</span> iterator = idleFunction()
<span class="hljs-comment">// L'exécution de la fonction est interrompue en attente d'être "débloquée"</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello'</span>)
iterator.next() <span class="hljs-comment">// L'éxécution reprend et on affiche "World"</span></code></pre>
<p>Notez qu’il ne s’agit pas de code <strong>bloquant</strong> : la fonction est mise en pause,
son traitement sera repris plus tard, pendant ce temps l’<em>event-loop</em> continue
sa petite vie.</p>
<h2 id="reprise-du-traitement-et-mission-de-valeur-avec-yield"><a class="markdownIt-Anchor" href="#reprise-du-traitement-et-mission-de-valeur-avec-yield">#</a> Reprise du traitement et émission de valeur avec <code>yield</code></h2>
<p>La méthode <code>next()</code> de l’itérateur retourne un objet possédant les propriétés
suivantes :</p>
<ul>
<li><code>done</code> vaut <code>true</code> quand le générateur a terminé son exécution</li>
<li><code>value</code> est la valeur émise par le générateur dans cette portion de code</li>
</ul>
<p>Comment émettre une valeur ? Le mot-clé <code>yield</code> a le double rôle de fournir
une valeur et de remettre en pause l’exécution de la fonction. Le principe étant
qu’on va émettre <strong>plusieurs</strong> valeurs, sinon on utiliserait simplement
<code>return</code>.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">numbers</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
}

<span class="hljs-keyword">const</span> iterator = numbers()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
iterator.next() <span class="hljs-comment">// { value: 2, done: false }</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<p>Note : si notre générateur <code>return</code> une valeur, elle sera affectée à la
propriété <code>value</code> de la dernière itération.</p>
<h3 id="use-case-listes-infinies"><a class="markdownIt-Anchor" href="#use-case-listes-infinies">#</a> <em>Use case</em> : listes infinies</h3>
<p>Un premier <em>use case</em> à ce stade est la possibilité de générer des listes de
longueur non définie à l’avance. On peut parcourir une suite dont on ne sait pas
à l’avance <em>combien</em> d’éléments on veut, par exemple récupérer tous les éléments
de la suite de Fibonacci inférieurs à 100 :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">fibo</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> [a, b] = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) { <span class="hljs-comment">// Who can stop me?</span>
    [a, b] = [b, a + b]
    <span class="hljs-keyword">yield</span> a
  }
}

<span class="hljs-keyword">const</span> iterator = fibo()
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> n <span class="hljs-keyword">of</span> iterator) {
  <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">100</span>) {
    <span class="hljs-keyword">break</span> <span class="hljs-comment">// *I* can stop you</span>
  }
  <span class="hljs-built_in">console</span>.log(n)
}
<span class="hljs-comment">// 1 2 3 5 8 13 21 34 55 89</span></code></pre>
<p>Note : l’opérateur <code>for … of</code> sera vu plus en détail dans un prochain article.</p>
<h2 id="passage-de-valeur-au-g-n-rateur"><a class="markdownIt-Anchor" href="#passage-de-valeur-au-g-n-rateur">#</a> Passage de valeur au générateur</h2>
<p>On a vu que <code>yield</code> permettait d’émettre une valeur depuis le générateur vers
le code contrôleur. Mais le sens inverse est également possible : la méthode
<code>next</code> de l’itérateur accepte une valeur en paramètre, qui sera alors
retournée par l’appel correspondant à <code>yield</code>. Exemple :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">math</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Le premier appel à next() permet de "démarrer" le générateur</span>
  <span class="hljs-keyword">const</span> x = <span class="hljs-keyword">yield</span> <span class="hljs-comment">// la valeur de la première itération sera undefined</span>
  <span class="hljs-comment">// x = le paramètre du second appel à next()</span>
  <span class="hljs-keyword">const</span> y = <span class="hljs-keyword">yield</span> x + <span class="hljs-number">1</span> <span class="hljs-comment">// valeur de la seconde itération : x + 1</span>
  <span class="hljs-comment">// y = paramètre du troisième appel à next()</span>
  <span class="hljs-keyword">yield</span> y <span class="hljs-comment">// valeur de la troisième itération : y</span>
  <span class="hljs-comment">// le 4e appel (et +) à next() retournent { value: undefined, done: true }</span>
}

<span class="hljs-keyword">const</span> iterator = math()
iterator.next(<span class="hljs-number">42</span>) <span class="hljs-comment">// { value: undefined, done: false }</span>
<span class="hljs-comment">// Passer un paramètre au premier appel à next() n'est pas utile : cette valeur</span>
<span class="hljs-comment">// n'est pas accessible dans le générateur car aucun "yield" correspondant</span>

iterator.next(<span class="hljs-number">33</span>) <span class="hljs-comment">// { value: 34, done: false }, x = 33 dans le générateur</span>
iterator.next(<span class="hljs-number">27</span>) <span class="hljs-comment">// { value: 27, done: false }, y = 27 dans le générateur</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<p>Ça ne semble pas très utile vu comme ça, mais on peut passer à <code>next()</code>
n’importe quel type de donnée : une fonction, un objet, un autre itérateur… Les
possibilités sont infinies. On va en explorer une rapidement avec les promesses.</p>
<h3 id="use-case-co-routines"><a class="markdownIt-Anchor" href="#use-case-co-routines">#</a> <em>Use case</em> : co-routines</h3>
<p>Le code du générateur lui-même ne peut être réellement asynchrone : les appels à
<code>yield</code> se suivent de manière synchrone. Le code contrôleur par contre, est
libre d’appeler <code>next()</code> à loisir, et peut donc le faire de manière asynchrone.</p>
<p>On a donc des fonctions dont on peut choisir quand elles sont interrompues, et
quand elles peuvent reprendre leur traitement. Et si… notre générateur émettait
des promesses ? Histoire d’expliquer à son code contrôleur <em>quand</em> il est sûr de
reprendre le traitement. Et si ce code contrôleur, voyant qu’il récupère une
promesse, attendait que cette dernière soit résolue pour transmettre au
générateur en retour la valeur résolue ? Dans ce cas le générateur pourrait
disposer de manière <strong>synchrone</strong> mais <strong>non bloquante</strong> de résultats de
traitements asynchrones :</p>
<pre><code class="language-js">execAsync(<span class="hljs-function"><span class="hljs-keyword">function</span> * (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Ajax request…"</span>)
  <span class="hljs-keyword">var</span> rows = <span class="hljs-keyword">yield</span> fetch(<span class="hljs-string">"http://my.api/get"</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Work…"</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Save…"</span>)
  <span class="hljs-keyword">yield</span> fetch(<span class="hljs-string">"http://my.api/post"</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"OK."</span>)
}) <span class="hljs-comment">// Ajax request… Work… Save… OK.</span></code></pre>
<p>Ne serait-ce pas merveilleux ? C’est le <em><em>use case</em></em> le plus intéressant pour
nous au quotidien, et c’est assez simple en fait :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">execAsync</span> (<span class="hljs-params">promiseGenerator</span>) </span>{
  <span class="hljs-keyword">const</span> iter = promiseGenerator() <span class="hljs-comment">// en pause…</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loop</span> (<span class="hljs-params">iteration</span>) </span>{
    <span class="hljs-keyword">if</span> (iteration.done) { <span class="hljs-comment">// Le générateur a return'é, fin du game</span>
      <span class="hljs-keyword">return</span> iteration.value
    }

    <span class="hljs-comment">// c'est un générateur de promesse, dont on attend la résolution ici</span>
    <span class="hljs-keyword">return</span> iteration.value.then(result =&gt; {
      <span class="hljs-comment">// La promesse est résolue, on peut repasser sa valeur au générateur</span>
      <span class="hljs-keyword">const</span> nextIteration = iter.next(result) <span class="hljs-comment">// cette valeur est return'ée par</span>
      <span class="hljs-comment">// le même "yield" qui a émis la promesse, ça tombe bien :)</span>

      <span class="hljs-comment">// Puis on relance notre boucle, et on continue récursivement</span>
      <span class="hljs-keyword">return</span> next(nextIteration)
    })
  }

  <span class="hljs-keyword">const</span> promiseIteration = iter.next() <span class="hljs-comment">// exécution reprise jusqu'au prochain "yield"</span>
  <span class="hljs-comment">// le générateur est remis en pause jusqu'au prochain appel à "iter.next"</span>

  <span class="hljs-comment">// Première itération de la boucle</span>
  <span class="hljs-keyword">return</span> loop(promiseIteration)
}</code></pre>
<h2 id="more-more-more"><a class="markdownIt-Anchor" href="#more-more-more">#</a> More! more! more!</h2>
<h3 id="gestion-d-erreur"><a class="markdownIt-Anchor" href="#gestion-d-erreur">#</a> Gestion d’erreur</h3>
<p>Les erreurs, tout comme les valeurs, peuvent être émises dans les deux
directions. Le générateur peut <code>throw</code> vers le code contrôleur (le code est
synchrone) :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">fail</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'oops'</span>)
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
}

<span class="hljs-keyword">const</span> iterator = fail()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
<span class="hljs-keyword">try</span> {
  iterator.next() <span class="hljs-comment">// throws</span>
} <span class="hljs-keyword">catch</span> (e) {
  e <span class="hljs-comment">// Error('oops')</span>
}</code></pre>
<p>Mais le code contrôleur peut également émettre une erreur vers le générateur
avec la méthode <code>throw</code> de l’itérateur :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">fail</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-built_in">console</span>.error(e)
  }
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
}

<span class="hljs-keyword">const</span> iterator = fail()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
iterator.throw(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"nope"</span>)) <span class="hljs-comment">// affiche "[Error: nope]"</span>
iterator.next() <span class="hljs-comment">// { value: 2, done: false }</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<p>Note : il faut bien se souvenir que le premier <code>next</code> sert à <em>débloquer</em>
l’exécution du générateur, qui va alors jusqu’au premier <code>yield</code>, évalue
l’expression émise, la transmet en retour de <code>next()</code>, et remet la fonction en
pause. C’est au second <code>yield</code> seulement que l’exécution reprend <strong>à partir de
<code>yield 1</code></strong>. C’est une partie que je trouve contre-intuitive et que j’ai eu du
mal à assimiler.</p>
<h3 id="d-l-gation"><a class="markdownIt-Anchor" href="#d-l-gation">#</a> Délégation</h3>
<p>L’opérateur <code>yield*</code> permet d’émettre les valeurs d’un autre itérateur, par
exemple :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">oneToThree</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">zeroToFour</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">0</span>
  <span class="hljs-keyword">yield</span> * oneToThree()
  <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span>
}</code></pre>
<p>Cela fonction bien sûr avec tous
<a href="/fr/articles/js/es2015/iterators/">les <em>itérables</em></a> :
<code>yield * [1, 2, 3]</code> est valide par exemple.</p>
<h3 id="retour-anticip"><a class="markdownIt-Anchor" href="#retour-anticip">#</a> Retour anticipé</h3>
<p>Il est possible de terminer le traitement d’un générateur depuis le code
contrôleur avec la méthode <code>return</code> de l’itérateur. Tout se passera comme si
le générateur se terminait immédiatement avec la valeur de retour fournie.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">numbers</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>
}

<span class="hljs-keyword">const</span> iterator = numbers()
iterator.next() <span class="hljs-comment">// { value: 1, done: false }</span>
iterator.return(<span class="hljs-number">4</span>) <span class="hljs-comment">// { value: 4, done: true } → yield 2 and yield 3 are skipped</span>
iterator.next() <span class="hljs-comment">// { value: undefined, done: true }</span></code></pre>
<h2 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion">#</a> Conclusion</h2>
<p>Un habituel petit coup d’œil sur <a href="https://kangax.github.io/compat-table/es6/#test-generators">la compatibilité</a> :</p>
<ul>
<li>Les navigateurs modernes (donc pas IE)</li>
<li>IE Edge ≥ 13</li>
<li>Niveau polyfill, c’est vers Babel ou Traceur qu’il faudra se tourner</li>
</ul>
<p>Les générateurs amènent tout un nouveau panel de fonctionnalités qui permettent
d’inverser la responsabilité : c’est le code appelant qui prend le pouvoir sur
la façon dont va s’exécuter la fonction appelée. Ils représentent le premier pas
vers d’autres concepts qui bouleverseront probablement votre façon de coder dans
quelques mois/années : fonctions asynchrones, observables… prennent leurs
racines dans les générateurs. Les comprendre permettra de mieux appréhender de
futures fonctionnalités.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/generators/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/generators/</guid><pubDate>Thu, 10 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : le protocole d'itération]]></title><description><![CDATA[<p>Imaginez un concept si important que si vous l’enleviez du langage, il faudrait
en conséquence enlever le spread, le destructuring, les générateurs, le for…of
et bien d’autres. Ce concept, introduit dans l’ES6, est en fait un protocole :
le protocole d’itération.</p>
<p>Le principe est de définir une convention dans le langage, qui permet de
standardiser la façon dont des sources de données peuvent être traversées.</p>
<p>Première bonne nouvelle, ce protocole est assez simple à comprendre et se base
sur 2 “interfaces” (oui les guillemets c’est pour dire qu’on ne parle pas
d’interface au sens technique, puisqu’elles n’existent pas en JS).</p>
<p>La première interface, appelée <strong>Iterator</strong> permet à un objet de produire des
valeurs en séquence. Un objet est un Iterator lorsqu’il implémente une
function <code>next()</code> qui retourne un objet avec 2 propriétés :</p>
<ul>
<li><code>value</code>: la valeur courante lors de l’itération</li>
<li><code>done</code> : un booléen qui indique si on a atteint la fin de l’itération ou non</li>
</ul>
<p>Les appels successifs à la méthode <code>next()</code> d’un Iterator permettent donc de
traverser et récupérer les valeurs d’un objet. Prenons l’exemple de l’Iterator
retourné par un Array qui contiendrait 2 valeurs (“a” et “b”) :</p>
<pre><code class="language-js">iteratorArray.next()
<span class="hljs-comment">// -&gt; Object {value: "a", done: false}</span>
iteratorArray.next()
<span class="hljs-comment">// -&gt; Object {value: "b", done: false}</span>
iteratorArray.next()
<span class="hljs-comment">// -&gt; Object {value: undefined, done: true}</span></code></pre>
<p>Mais comment récupérer l’Iterator d’un objet vas-tu me dire ? (n’est-ce pas ?)
Ça tombe bien, c’est le rôle de la seconde interface, appelée <strong>Iterable</strong>. Un
objet est Iterable s’il implémente une méthode particulière qui va retourner
l’Iterator. Cette méthode particulière (appelée <em>@@iterator</em> dans la
spécification) doit être définie en utilisant le symbole <code>[Symbol.iterator]</code>.
(Les symboles seront expliqués dans un prochain article, pas de panique).</p>
<p>En reprenant l’exemple précédent, voici comment récupérer l’Iterator d’un Array :</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>]
<span class="hljs-keyword">const</span> iteratorArray = arr[<span class="hljs-built_in">Symbol</span>.iterator]()
iteratorArray.next()
<span class="hljs-comment">// -&gt; Object {value: "a", done: false}</span>
iteratorArray.next()
<span class="hljs-comment">// -&gt; Object {value: "b", done: false}</span>
iteratorArray.next()
<span class="hljs-comment">// -&gt; Object {value: undefined, done: true}</span></code></pre>
<p>L’exemple ci-dessus illustre donc l’implémentation du protocole par l’Array.
Il n’est pas très utile en soi, en voici donc un autre qui va permettre de
boucler sur les valeurs et les afficher :</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>]
<span class="hljs-keyword">var</span> iterator = arr[<span class="hljs-built_in">Symbol</span>.iterator]()

<span class="hljs-keyword">var</span> result = iterator.next()
<span class="hljs-keyword">while</span> (!result.done) {
  <span class="hljs-built_in">console</span>.log(result.value)
  result = iterator.next()
}
<span class="hljs-comment">// 'a'</span>
<span class="hljs-comment">// 'b'</span></code></pre>
<p>De manière générale, quand un objet qui implémente le protocole d’itération est
traversé, sa méthode <em>@@iterator</em> est appelée (une seule fois donc) et l’Iterator
retourné est utilisé pour boucler sur ses valeurs.</p>
<h1 id="consommateurs-d-iterable"><a class="markdownIt-Anchor" href="#consommateurs-d-iterable">#</a> Consommateurs d’Iterable</h1>
<p>La deuxième bonne nouvelle, c’est que plusieurs concepts du langage tirent avantage de ce protocole :</p>
<ul>
<li>Certaines syntaxes s’attendent à recevoir des Iterables</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>]

<span class="hljs-comment">// La syntaxe à laquelle on pense immédiatement est la syntaxe « for .. of »</span>
<span class="hljs-comment">// qui permet de boucler sur les valeurs des Iterables.</span>
<span class="hljs-keyword">for</span> (val <span class="hljs-keyword">of</span> arr) {
    <span class="hljs-built_in">console</span>.log(val)
}

<span class="hljs-comment">// Le spread qui permet d'insérer facilement des valeurs dans un Array</span>
<span class="hljs-comment">// utilise également des Iterable</span>
[<span class="hljs-string">'0'</span>, ...arr, <span class="hljs-string">'1'</span>] <span class="hljs-comment">// 0, a, b, 1</span>

<span class="hljs-comment">// yield nécessite également des Iterable</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gen</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">yield</span>* arr
}
gen().next() <span class="hljs-comment">// { value:"a", done:false }</span>

<span class="hljs-comment">// Le destructuring avec le pattern Array</span>
<span class="hljs-keyword">const</span> [x, y] = arr <span class="hljs-comment">// x = 'a',  y = "b"</span></code></pre>
<ul>
<li>Des API acceptent également des Iterables</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"b"</span>]

<span class="hljs-comment">// Certains constructeurs acceptent des Iterable</span>

<span class="hljs-comment">// Set et Weakset</span>
<span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr)
set.has(<span class="hljs-string">"b"</span>) <span class="hljs-comment">// true</span>
<span class="hljs-comment">// Map et WeakMap</span>
<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(arr.entries()) <span class="hljs-comment">// Attention, le constructeur attend un ensemble [clé, valeur]</span>
map.get(<span class="hljs-number">0</span>) <span class="hljs-comment">// 'a'</span>


<span class="hljs-comment">// Ou encore les API suivants :</span>

<span class="hljs-built_in">Array</span>.from(iterable) <span class="hljs-comment">// transforme n'importe quel Iterable en Array.</span>
<span class="hljs-built_in">Promise</span>.all(iterableCollectionDePromises) <span class="hljs-comment">// n'importe quel Iterable qui contient un ensemble de Promises</span>
<span class="hljs-built_in">Promise</span>.race(iterableCollectionDePromises) <span class="hljs-comment">// idem</span></code></pre>
<h1 id="built-in-iterable"><a class="markdownIt-Anchor" href="#built-in-iterable">#</a> Built-in Iterable</h1>
<p>Troisième bonne nouvelle, plusieurs objets du langage implémentent déjà ce protocole :</p>
<pre><code class="language-js"><span class="hljs-comment">// évidemment les Array</span>
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"l"</span>, <span class="hljs-string">"o"</span>, <span class="hljs-string">"l"</span>]
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> arr) {
  <span class="hljs-built_in">console</span>.log(v)
  <span class="hljs-comment">// 'l'</span>
  <span class="hljs-comment">// 'o'</span>
  <span class="hljs-comment">// 'l'</span>
}

<span class="hljs-comment">// les String</span>
<span class="hljs-keyword">const</span> str = <span class="hljs-string">"lol"</span>
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> str) {
  <span class="hljs-built_in">console</span>.log(v)
  <span class="hljs-comment">// 'l'</span>
  <span class="hljs-comment">// 'o'</span>
  <span class="hljs-comment">// 'l'</span>
}

<span class="hljs-comment">// les Map et Set (mais PAS WeakMap et WeakSet)</span>
<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>().set(<span class="hljs-string">'l'</span>, <span class="hljs-number">1</span>).set(<span class="hljs-string">'o'</span>, <span class="hljs-number">2</span>)
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> map) {
  <span class="hljs-built_in">console</span>.log(v)
  <span class="hljs-comment">// ["l", 1]</span>
  <span class="hljs-comment">// ["o", 2]</span>
}
<span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>().add(<span class="hljs-string">'l'</span>).add(<span class="hljs-string">'o'</span>)
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> map) {
  <span class="hljs-built_in">console</span>.log(v)
  <span class="hljs-comment">// 'l'</span>
  <span class="hljs-comment">// 'o'</span>
}

<span class="hljs-comment">// Les TypedArray que vous utilisez tous les jours</span>
<span class="hljs-keyword">const</span> int16 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int16Array</span>(<span class="hljs-number">2</span>)
int16[<span class="hljs-number">0</span>] = <span class="hljs-number">42</span>
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> int16) {
  <span class="hljs-built_in">console</span>.log(v)
  <span class="hljs-comment">// 42</span>
  <span class="hljs-comment">// 0</span>
}

<span class="hljs-comment">// Même l'objet spécial arguments (que vous</span>
<span class="hljs-comment">// ne devriez plus utiliser avec l'ES6) est un Iterable</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> <span class="hljs-built_in">arguments</span>) {
    <span class="hljs-built_in">console</span>.log(v)
    <span class="hljs-comment">// 'l'</span>
    <span class="hljs-comment">// 'o'</span>
    <span class="hljs-comment">// 'l'</span>
  }
}
test(<span class="hljs-string">'l'</span>, <span class="hljs-string">'o'</span>, <span class="hljs-string">'l'</span>)

<span class="hljs-comment">// Les NodeList retournés par l'API DOM également !</span>
<span class="hljs-keyword">const</span> matches = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'div'</span>)
<span class="hljs-keyword">for</span> (m <span class="hljs-keyword">of</span> matches) {
  <span class="hljs-built_in">console</span>.log(m)
  <span class="hljs-comment">// &lt;div id="topSection"&gt;</span>
  <span class="hljs-comment">// &lt;div id="brandLogo"&gt;</span>
  <span class="hljs-comment">// ...</span>
}</code></pre>
<p>Autre point : Array, TypedArray, Map, Set sont des Iterable mais définissent
aussi des méthodes qui retournent également des Iterable (ça va, vous suivez
toujours ?) :</p>
<ul>
<li>entries() retourne un ensemble des clés/valeurs</li>
<li>keys() retourne les clés</li>
<li>values() retourne les valeurs</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (cleVals <span class="hljs-keyword">of</span> arr.entries()) {
  <span class="hljs-built_in">console</span>.log(cleVals)
  <span class="hljs-comment">// [0, "l"]</span>
  <span class="hljs-comment">// [1, "o"]</span>
  <span class="hljs-comment">// [2, "l"]</span>
}</code></pre>
<p>Détail important, <code>Object</code> n’est pas Iterable mais il n’est pas impossible de
voir apparaitre dans l’ES7 les méthodes entries(), keys() et values() sur
Object (cf.
<a href="https://github.com/tc39/proposal-object-values-entries">la proposition spec</a>).</p>
<h1 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion">#</a> Conclusion</h1>
<p>J’espère que cet article a bien illustré l’importance de ce protocole dans le
langage. Nous avons vu ci-dessus que de nombreux concepts du langage tirent
déjà avantage de ce protocole mais il est au moins aussi important de noter que
cela permet d’établir une convention sur laquelle des librairies externes peuvent
s’appuyer.</p>
<p>Elles peuvent le faire de 2 manières :</p>
<ul>
<li>en proposant des sources de données qui implémentent le protocole (ex:
liste chaînée)</li>
<li>en tant que consommateur du protocole (ex: un algorithme de tri)</li>
</ul>
<h1 id="un-dernier-verre-pour-la-route"><a class="markdownIt-Anchor" href="#un-dernier-verre-pour-la-route">#</a> Un dernier verre pour la route</h1>
<p>Les articles suivants vous permettront d’aller encore plus loin dans le sujet. Vous y
apprendrez notamment qu’un iterator peut retourner en option 2 autres méthodes,
qu’un générateur est à la fois un Iterable et un Iterator, qu’un Iterable peut
être infini ou encore des exemples d’implémentations divers et variés :</p>
<ul>
<li><a href="http://www.2ality.com/2015/02/es6-iteration.html">Iterables and iterators in ECMAScript 6</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">Iteration Protocols</a></li>
<li><a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/">ES6 in depth : iterators and the for of loop</a></li>
<li><a href="https://ponyfoo.com/articles/es6-iterators-in-depth">ES6 iterators in depth</a></li>
</ul>
<p>La pratique restant le meilleur moyen de se former, le site
<a href="http://es6katas.org/">ES6 Katas</a> est très bien fait pour s’exercer.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/iterators/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/iterators/</guid><pubDate>Wed, 09 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : Iteration protocol]]></title><description><![CDATA[<p>Imagine something so big, that if you remove it from the language, you will need
to remove lots of others features like spread operator, destructuring,
generators, for of…
This thing is just a protocol: the iterator protocol.</p>
<p>The principle is just a convention in the language which allow to standardise
how we can iterate on some data.</p>
<p>First good news, this protocol is pretty simple to understand and use 2
“interfaces” (quotes are just to warn you that we cannot really call that
<em>Interface</em>, since we don’t have this “thing” in JavaScript).</p>
<p>The first interface, <strong>Iterator</strong>, allow to an object to produce sequences of
values. An object is an iterator when it implements a <code>next()</code> function
which return an object that contains two properties :</p>
<ul>
<li><code>value</code>: current value of the current execution</li>
<li><code>done</code> : a boolean that indicates whether the iteration is finished or not</li>
</ul>
<p>Successif calls of the <code>next()</code> method of an iterator will allow to get all
the value of an object.
Let’s see how we can iterate on a simple array <code>[&quot;a&quot;, &quot;b&quot;]</code> :</p>
<pre><code class="language-js">iteratorArray.next()
<span class="hljs-comment">// -&gt; Object {value: "a", done: false}</span>
iteratorArray.next()
<span class="hljs-comment">// -&gt; Object {value: "b", done: false}</span>
iteratorArray.next()
<span class="hljs-comment">// -&gt; Object {value: undefined, done: true}</span></code></pre>
<p>So you will probably now ask “How to get this Iterator?”.
That’s the second interface,  <strong>Iterable</strong>.
An iterable object implements a particular method which is going to return an
iterator.
This method (called <em>@@iterator</em> in the spec) must be defined using the
Symbol <code>[Symbol.iterator]</code>.
(Symbol will be explained in a dedicated).</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>]
<span class="hljs-keyword">const</span> iteratorArray = arr[<span class="hljs-built_in">Symbol</span>.iterator]()
iteratorArray.next()
<span class="hljs-comment">// -&gt; Object {value: "a", done: false}</span>
iteratorArray.next()
<span class="hljs-comment">// -&gt; Object {value: "b", done: false}</span>
iteratorArray.next()
<span class="hljs-comment">// -&gt; Object {value: undefined, done: true}</span></code></pre>
<p>Now you know how to use the array iterator implementation.
Not really useful right?
Here is another example to loop on an array following this protocol :</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>]
<span class="hljs-keyword">const</span> iterator = arr[<span class="hljs-built_in">Symbol</span>.iterator]()

<span class="hljs-keyword">const</span> result = iterator.next()
<span class="hljs-keyword">while</span> (!result.done) {
  <span class="hljs-built_in">console</span>.log(result.value)
  result = iterator.next()
}
<span class="hljs-comment">// 'a'</span>
<span class="hljs-comment">// 'b'</span></code></pre>
<p>Let’s recap: when an object which implements the iteration protocol is traversed
its <em>@@iterator</em> method is called once and the iterator is returned to be used
to loop an all values.</p>
<h1 id="iterable-consumers"><a class="markdownIt-Anchor" href="#iterable-consumers">#</a> Iterable consumers</h1>
<p>Second good new is that a lots of concept of JavaScript benefits of this
protocol :</p>
<ul>
<li>Some syntaxes expect to get iterables</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>]

<span class="hljs-comment">// for...of has been precisely made to loop on custom iterables</span>
<span class="hljs-keyword">for</span> (val <span class="hljs-keyword">of</span> arr) {
    <span class="hljs-built_in">console</span>.log(val)
}

<span class="hljs-comment">// spred operator will use it too</span>
[<span class="hljs-string">'0'</span>, ...arr, <span class="hljs-string">'1'</span>] <span class="hljs-comment">// 0, a, b, 1</span>

<span class="hljs-comment">// yield also needs an iterator</span>
<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gen</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">yield</span>* arr
}
gen().next() <span class="hljs-comment">// { value:"a", done:false }</span>

<span class="hljs-comment">// same for destructuring</span>
<span class="hljs-keyword">const</span> [x, y] = arr <span class="hljs-comment">// x = 'a',  y = "b"</span></code></pre>
<ul>
<li>Some APIs acccepts iterables</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"b"</span>]

<span class="hljs-comment">// Set and Weakset accepts iterables</span>
<span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr)
set.has(<span class="hljs-string">"b"</span>) <span class="hljs-comment">// true</span>
<span class="hljs-comment">// same for Map and WeakMap</span>
<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(arr.entries()) <span class="hljs-comment">// Not that a (weak)map needs a [key, value] combo</span>
map.get(<span class="hljs-number">0</span>) <span class="hljs-comment">// 'a'</span>


<span class="hljs-comment">// MOAR APIs</span>

<span class="hljs-built_in">Array</span>.from(iterable) <span class="hljs-comment">// tunr anything into an array !</span>
<span class="hljs-built_in">Promise</span>.all(iterableCollectionDePromises) <span class="hljs-comment">// any iterable that will contains a set of Promises</span>
<span class="hljs-built_in">Promise</span>.race(iterableCollectionDePromises) <span class="hljs-comment">// same</span></code></pre>
<h1 id="built-in-iterable"><a class="markdownIt-Anchor" href="#built-in-iterable">#</a> Built-in Iterable</h1>
<p>Third good news: a lot’s of objects already implement this protocol :</p>
<pre><code class="language-js"><span class="hljs-comment">// obviously, arrays</span>
<span class="hljs-keyword">const</span> arr = [<span class="hljs-string">"l"</span>, <span class="hljs-string">"o"</span>, <span class="hljs-string">"l"</span>]
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> arr) {
  <span class="hljs-built_in">console</span>.log(v)
  <span class="hljs-comment">// 'l'</span>
  <span class="hljs-comment">// 'o'</span>
  <span class="hljs-comment">// 'l'</span>
}

<span class="hljs-comment">// strings too</span>
<span class="hljs-keyword">const</span> str = <span class="hljs-string">"lol"</span>
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> str) {
  <span class="hljs-built_in">console</span>.log(v)
  <span class="hljs-comment">// 'l'</span>
  <span class="hljs-comment">// 'o'</span>
  <span class="hljs-comment">// 'l'</span>
}

<span class="hljs-comment">// Map and Set (BUT NOT WeakMap and WeakSet)</span>
<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>().set(<span class="hljs-string">'l'</span>, <span class="hljs-number">1</span>).set(<span class="hljs-string">'o'</span>, <span class="hljs-number">2</span>)
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> map) {
  <span class="hljs-built_in">console</span>.log(v)
  <span class="hljs-comment">// ["l", 1]</span>
  <span class="hljs-comment">// ["o", 2]</span>
}
<span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>().add(<span class="hljs-string">'l'</span>).add(<span class="hljs-string">'o'</span>)
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> map) {
  <span class="hljs-built_in">console</span>.log(v)
  <span class="hljs-comment">// 'l'</span>
  <span class="hljs-comment">// 'o'</span>
}

<span class="hljs-comment">// TypedArray that you use EVERY SINGLE DAYS</span>
<span class="hljs-keyword">const</span> int16 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int16Array</span>(<span class="hljs-number">2</span>)
int16[<span class="hljs-number">0</span>] = <span class="hljs-number">42</span>
<span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> int16) {
  <span class="hljs-built_in">console</span>.log(v)
  <span class="hljs-comment">// 42</span>
  <span class="hljs-comment">// 0</span>
}

<span class="hljs-comment">// Even the special `argument` object</span>
<span class="hljs-comment">// (that you will probably stop to use in es6, thanks to spread operator)</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> <span class="hljs-built_in">arguments</span>) {
    <span class="hljs-built_in">console</span>.log(v)
    <span class="hljs-comment">// 'l'</span>
    <span class="hljs-comment">// 'o'</span>
    <span class="hljs-comment">// 'l'</span>
  }
}
test(<span class="hljs-string">'l'</span>, <span class="hljs-string">'o'</span>, <span class="hljs-string">'l'</span>)

<span class="hljs-comment">// NodeList returned by DOM APIs</span>
<span class="hljs-keyword">const</span> matches = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'div'</span>)
<span class="hljs-keyword">for</span> (m <span class="hljs-keyword">of</span> matches) {
  <span class="hljs-built_in">console</span>.log(m)
  <span class="hljs-comment">// &lt;div id="topSection"&gt;</span>
  <span class="hljs-comment">// &lt;div id="brandLogo"&gt;</span>
  <span class="hljs-comment">// ...</span>
}</code></pre>
<p>Another detail: Array, TypedArray, Map, Set are iterables but also define
methods which also return iterables (…Are you still with us ?) :</p>
<ul>
<li>entries() returns a set of key/values</li>
<li>keys() returns keys</li>
<li>values() returns values</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">for</span> (cleVals <span class="hljs-keyword">of</span> arr.entries()) {
  <span class="hljs-built_in">console</span>.log(cleVals)
  <span class="hljs-comment">// [0, "l"]</span>
  <span class="hljs-comment">// [1, "o"]</span>
  <span class="hljs-comment">// [2, "l"]</span>
}</code></pre>
<p>Important note: <code>Object</code> is not an iterable (but we might get in ES2016
entries(), keys() and values() on <code>Object</code>
(<a href="https://github.com/tc39/proposal-object-values-entries">spec proposal</a>).</p>
<h1 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion">#</a> Conclusion</h1>
<p>We have seen that a lots of interesting syntaxes and features use the iterable
protocol, so we hope that you will use all of that in your libraries.
That’s important to rely on commons patterns so we can reach an agreement.</p>
<p>Libraries can do that by :</p>
<ul>
<li>offering data that implements this protocol</li>
<li>use this protocol directly (eg: for a sorting algorithm)</li>
</ul>
<h1 id="one-last-thing"><a class="markdownIt-Anchor" href="#one-last-thing">#</a> One last thing…</h1>
<p>The following post will allow you to deep dive into this subject :</p>
<ul>
<li><a href="http://www.2ality.com/2015/02/es6-iteration.html">Iterables and iterators in ECMAScript 6</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">Iteration Protocols</a></li>
<li><a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/">ES6 in depth : iterators and the for of loop</a></li>
<li><a href="https://ponyfoo.com/articles/es6-iterators-in-depth">ES6 iterators in depth</a></li>
</ul>
<p>The practice remains the best way to train yourself, so take a look to
<a href="http://es6katas.org/">ES6 Katas</a> which has been made for that.</p>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/iterators/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/iterators/</guid><pubDate>Wed, 09 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : Object literals]]></title><description><![CDATA[<p>Again, ES6 brings us more syntax sugar, that you might appreciate when
creating new object.</p>
<h2 id="shorter-property-name"><a class="markdownIt-Anchor" href="#shorter-property-name">#</a> Shorter property name</h2>
<p>When you create an object, you might create a variable and then reuse it to
define a property of an object that have the same name.</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> firstname = <span class="hljs-string">"Robert"</span>
<span class="hljs-keyword">var</span> lastname = <span class="hljs-string">"Laiponje"</span>

<span class="hljs-keyword">return</span> {
  firstname: firstname,
  lastname: lastname,
}</code></pre>
<p>Thanks to ES6, you can directly write:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> firstname = <span class="hljs-string">"Robert"</span>
<span class="hljs-keyword">const</span> lastname = <span class="hljs-string">"Laiponje"</span>

<span class="hljs-keyword">return</span> {
  firstname,
  lastname,
}
<span class="hljs-comment">// { firstname: "Robert", lastname: "Laiponje" }</span></code></pre>
<p>In the same spirit, you will be able to declare methods without the <code>function</code>
keyword (this also apply for <em>getter</em> and <em>setter</em>).</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> obj = {
  get email() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.email()
  },
  set email(email) {
    <span class="hljs-keyword">this</span>.email = email
  },
  validateEmail(email) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  },
}</code></pre>
<h2 id="dynamic-property-name"><a class="markdownIt-Anchor" href="#dynamic-property-name">#</a> Dynamic property name</h2>
<p>One last thing for <em>objects literal</em> will allow you to create dynamic property
name using an expression, directly when you create an object.
With ES5 you have to do that in two steps:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">type, data</span>) </span>{
  <span class="hljs-keyword">var</span> payload = {}
  payload[type] = data
  <span class="hljs-keyword">return</span> payload
}</code></pre>
<p>Now with ES6, you can do:</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">type, data</span>) </span>{
  <span class="hljs-keyword">return</span> {
    [type]: data
  }
}</code></pre>
<p><strong>Note:</strong> with dynamic properties, declaring multiples properties with the same
name is accepted and do not throw an error. Keep in mind that only the last
value will be kept.</p>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/object-literals/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/object-literals/</guid><pubDate>Tue, 08 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : Les object literals]]></title><description><![CDATA[<p>Là encore, cette évolution du langage amène un sucre syntaxique bien pratique
lors de l’initialisation d’objets.</p>
<h2 id="nom-des-propri-t-s-raccourcies"><a class="markdownIt-Anchor" href="#nom-des-propri-t-s-raccourcies">#</a> Nom des propriétés raccourcies</h2>
<p>Lorsqu’on crée un objet, il arrive fréquemment que lorsqu’on définisse une
propriété depuis une variable, la clé porte le même nom que la variable.</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> firstname = <span class="hljs-string">"Robert"</span>
<span class="hljs-keyword">var</span> lastname = <span class="hljs-string">"Laiponje"</span>

<span class="hljs-keyword">return</span> {
  firstname: firstname,
  lastname: lastname,
}</code></pre>
<p>Avec ES2015, on va pouvoir l’écrire comme ça :</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> firstname = <span class="hljs-string">"Robert"</span>
<span class="hljs-keyword">const</span> lastname = <span class="hljs-string">"Laiponje"</span>

<span class="hljs-keyword">return</span> {
  firstname,
  lastname,
}
<span class="hljs-comment">// { firstname: "Robert", lastname: "Laiponje" }</span></code></pre>
<p>De la même manière, on pourra déclarer des méthodes en se passant du mot clé
<code>function</code>. Idem pour les <em>getter</em> / <em>setter</em>.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> obj = {
  get email() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.email()
  },
  set email(email) {
    <span class="hljs-keyword">this</span>.email = email
  },
  validateEmail(email) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  },
}</code></pre>
<h2 id="nom-de-propri-t-s-calcul-es"><a class="markdownIt-Anchor" href="#nom-de-propri-t-s-calcul-es">#</a> Nom de propriétés calculées</h2>
<p>La dernière nouveauté concernant les <em>literal objects</em> va nous permettre
de créer des noms de propriétés depuis une expression, directement à la
création de l’objet. Auparavant, il fallait procéder en 2 temps, création
puis affectation.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">type, data</span>) </span>{
  <span class="hljs-keyword">var</span> payload = {}
  payload[type] = data
  <span class="hljs-keyword">return</span> payload
}</code></pre>
<p>En ES2015, cela donnerait :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">action</span>(<span class="hljs-params">type, data</span>) </span>{
  <span class="hljs-keyword">return</span> {
    [type]: data
  }
}</code></pre>
<p><strong>À noter</strong> qu’avec l’introduction des propriétés calculées, on va pouvoir
aussi déclarer plusieurs fois une même propriété, la dernière déclaration
écrasant les précédentes (et plus de <code>syntaxError</code>).</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/object-literals/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/object-literals/</guid><pubDate>Tue, 08 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : les template strings]]></title><description><![CDATA[<p>ES2015 ajoute le support des <em>template strings</em> qui va permettre enfin de se
simplifier la vie lorsqu’on doit manipuler des chaînes de caractères.</p>
<h2 id="le-principe"><a class="markdownIt-Anchor" href="#le-principe">#</a> Le principe</h2>
<p>Pour définir une chaîne en JavaScript, il faut utiliser soit des single quotes,
soit des double quotes. Malheureusement ces délimiteurs posent quelques
problèmes lorsque justement la chaîne contient un single quote ou une
double quote.</p>
<p>Ainsi, les <em>template strings</em> utilisent le caractère <em>back-tick</em> (accent grave
simple) pour délimiter les chaînes de caractères.</p>
<pre><code class="language-js"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> myString = <span class="hljs-string">'Je suis une "chaîne de caractères"'</span>

<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">const</span> myNewString = <span class="hljs-string">`Je suis une "template string"`</span></code></pre>
<p>Jusque là, rien de bien novateur mais voyons un exemple que l’on rencontre
tout le temps : l’interpolation d’expression dans les chaînes de texte.</p>
<h2 id="interpolation-d-expression"><a class="markdownIt-Anchor" href="#interpolation-d-expression">#</a> Interpolation d’expression</h2>
<p>On peut maintenant directement utiliser les variables dans une <em>template string</em>
si on les insère dans un placeholder qui s’écrit <code>${variable}</code>.</p>
<pre><code class="language-js"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> name = <span class="hljs-string">"world"</span>;
<span class="hljs-keyword">var</span> myStrin = <span class="hljs-string">"Hello "</span> + name; <span class="hljs-comment">// =&gt; Hello world</span>

<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">const</span> newName = <span class="hljs-string">`developer`</span>;
<span class="hljs-keyword">const</span> myStrin = <span class="hljs-string">`Hello <span class="hljs-subst">${ newName }</span>`</span>; <span class="hljs-comment">// =&gt; Hello developer</span></code></pre>
<p>Il est également possible de faire des traitements dans un placeholder et
d’appeler des fonctions.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> x = <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> y = <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> result = <span class="hljs-string">`<span class="hljs-subst">${ x }</span> + <span class="hljs-subst">${ y }</span> = <span class="hljs-subst">${ x + y }</span>`</span> <span class="hljs-comment">// =&gt; 1 + 2 = 3</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">num</span>) </span>{
  <span class="hljs-keyword">return</span> num * num;
}
<span class="hljs-keyword">const</span> result = <span class="hljs-string">`<span class="hljs-subst">${square(5)}</span>`</span> <span class="hljs-comment">// =&gt; 25</span></code></pre>
<p>Ce qui rend l’utilisation des <em>template strings</em> extrêmement intéressante.</p>
<h2 id="les-template-strings-multi-lignes"><a class="markdownIt-Anchor" href="#les-template-strings-multi-lignes">#</a> Les <em>template strings</em> multi-lignes</h2>
<p>Une autre avancée des <em>template strings</em> est le support multi-ligne, en effet en
ES5 il n’existe aucune solution esthétique (et pratique) pour générer des
chaînes multi-lignes.
Ce problème disparait avec les <em>template strings</em>.</p>
<pre><code class="language-js"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> multiline = <span class="hljs-string">"foo \
                 bar \
                 baz"</span>;

<span class="hljs-keyword">var</span> multiline2 = <span class="hljs-string">"foo"</span>;
multiline2 += <span class="hljs-string">"bar"</span>;
multiline2 += <span class="hljs-string">"baz"</span>;

<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">const</span> multiline = <span class="hljs-string">`foo
                   bar
                   baz`</span>;</code></pre>
<p><em>Attention</em> cependant, les espaces sont conservés avec les <em>template strings</em>,
ce qui peut surprendre si vous devez tester des strings multi-lignes.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> str1 = <span class="hljs-string">`foo
bar`</span>;

<span class="hljs-keyword">const</span> str2 = <span class="hljs-string">`foo
             bar`</span>;

str1 === str2 <span class="hljs-comment">// =&gt; false</span></code></pre>
<h2 id="les-template-strings-taggu-s"><a class="markdownIt-Anchor" href="#les-template-strings-taggu-s">#</a> Les <em>template strings</em> taggués</h2>
<p>On entre dans les fonctions moins connues et peu utilisées des <em>template strings</em>.
Les tags sont des fonctions que l’on place juste avant une <em>template string</em> et
qui permettent de modifier le contenu de la dite chaîne de caractères.</p>
<p>Ce tag aura pour paramètres un tableau de “literals” (les chaînes de caractères),
et ensuite tous les paramètres correspondant aux valeurs interpolées qui auront
déjà été évaluées, mais que l’on pourra quand même modifier.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">capitalizeVowels</span>(<span class="hljs-params">strings, ...values</span>) </span>{

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replaceVowels</span>(<span class="hljs-params">string</span>) </span>{
    <span class="hljs-keyword">return</span> string.replace(<span class="hljs-regexp">/[aeiou]/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">c</span>)</span>{
      <span class="hljs-keyword">return</span> c.toUpperCase();
    });
  }

  <span class="hljs-keyword">let</span> result = <span class="hljs-string">""</span>;
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; strings.length; ++i) {
    <span class="hljs-keyword">const</span> nextValue = values[i] || <span class="hljs-string">""</span>;
    result += replaceVowels(strings[i]);
    <span class="hljs-keyword">if</span>(! <span class="hljs-built_in">parseInt</span>(nextValue)) {
      result += replaceVowels(nextValue)
    } <span class="hljs-keyword">else</span> {
      result += nextValue;
    }
  }
  <span class="hljs-keyword">return</span> result;
}


capitalizeVowels<span class="hljs-string">`foo bar ?`</span> <span class="hljs-comment">// =&gt; fOO bAr ?</span>
<span class="hljs-keyword">const</span> n = <span class="hljs-number">42</span>
<span class="hljs-keyword">const</span> c = <span class="hljs-string">"f"</span>
<span class="hljs-keyword">const</span> v = <span class="hljs-string">"o"</span>
capitalizeVowels<span class="hljs-string">`foo <span class="hljs-subst">${ n }</span> bar <span class="hljs-subst">${ c }</span><span class="hljs-subst">${ v }</span><span class="hljs-subst">${ v }</span> ?`</span> <span class="hljs-comment">// =&gt; fOO 42 bAr fOO ?</span></code></pre>
<p>Voici un exemple intéressant d’utilisation des <em>template strings</em> taggués qui
présente un système <a href="http://jaysoo.ca/2014/03/20/i18n-with-es6-template-strings/">de localisation de chaînes de caractères</a>.</p>
<h2 id="string-raw"><a class="markdownIt-Anchor" href="#string-raw">#</a> String.raw</h2>
<p>Et pour finir, une nouvelle fonction a été ajoutée au prototype de <code>String</code> qui
permet d’afficher le contenu d’un <em>template string</em> brut. C’est à dire que la
fonction permettra de voir les caractères d’échappement qui sont
automatiquement gérés avec une <em>template string</em>.</p>
<pre><code class="language-js"><span class="hljs-built_in">String</span>.raw<span class="hljs-string">`FOO\nbar`</span> <span class="hljs-comment">// =&gt; FOO\\nbar</span></code></pre>
<h2 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion">#</a> Conclusion</h2>
<p>Les <em>template strings</em> sont bien utiles au quotidien, l’ajout de l’interpolation
simplifie grandement la vie et permet d’oublier les erreurs d’échappement.</p>
<p>Aujourd’hui, <a href="https://kangax.github.io/compat-table/es6/#test-template_strings">la grande majorité des navigateurs les supportent</a>
ainsi que babel et traceur, donc usez et abusez des <em>template strings</em>…</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/template-strings/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/template-strings/</guid><pubDate>Mon, 07 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : Template strings]]></title><description><![CDATA[<p>ES2015 add a new way to write better strings that will simplify our code:
the <em>template strings</em>.</p>
<h2 id="principle"><a class="markdownIt-Anchor" href="#principle">#</a> Principle</h2>
<p>To define a string in JavaScript, we have single quotes or double quotes.
No one is really better than the other since you need to escape the quotes you
are using in the string itself.</p>
<p><em>Template strings</em> use <em>back-tick</em> (grave accent) to delimitate strings.</p>
<pre><code class="language-js"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> myString = <span class="hljs-string">'I\'m a "string"'</span>

<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">const</span> myNewString = <span class="hljs-string">`I'm a "template string"`</span></code></pre>
<p>Nothing really awesome. So let’s see the interesting new feature: interpolation.</p>
<h2 id="interpolation"><a class="markdownIt-Anchor" href="#interpolation">#</a> Interpolation</h2>
<p>Now you can directly use expression in a <em>template string</em> if you use the new
place holder syntax.: <code>${ expression }</code>.</p>
<pre><code class="language-js"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> name = <span class="hljs-string">"world"</span>;
<span class="hljs-keyword">var</span> myStrin = <span class="hljs-string">"Hello "</span> + name; <span class="hljs-comment">// =&gt; Hello world</span>

<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">const</span> newName = <span class="hljs-string">`developer`</span>;
<span class="hljs-keyword">const</span> myStrin = <span class="hljs-string">`Hello <span class="hljs-subst">${ newName }</span>`</span>; <span class="hljs-comment">// =&gt; Hello developer</span></code></pre>
<p>Here we are just using a variable, but we can use any expression:</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> x = <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> y = <span class="hljs-number">2</span>;
<span class="hljs-keyword">const</span> result = <span class="hljs-string">`<span class="hljs-subst">${ x }</span> + <span class="hljs-subst">${ y }</span> = <span class="hljs-subst">${ x + y }</span>`</span> <span class="hljs-comment">// =&gt; 1 + 2 = 3</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">num</span>) </span>{
  <span class="hljs-keyword">return</span> num * num;
}
<span class="hljs-keyword">const</span> result = <span class="hljs-string">`<span class="hljs-subst">${square(5)}</span>`</span> <span class="hljs-comment">// =&gt; 25</span></code></pre>
<p>This is what make <em>template strings</em> awesome.</p>
<h2 id="template-strings-are-multi-lines-capable"><a class="markdownIt-Anchor" href="#template-strings-are-multi-lines-capable">#</a> <em>template strings</em> are multi-lines capable</h2>
<p>Another cool thing is that <em>template strings</em> handle multi-lines.</p>
<pre><code class="language-js"><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">var</span> multiline = <span class="hljs-string">"foo \
                 bar \
                 baz"</span>;

<span class="hljs-keyword">var</span> multiline2 = <span class="hljs-string">"foo"</span>;
multiline2 += <span class="hljs-string">"bar"</span>;
multiline2 += <span class="hljs-string">"baz"</span>;

<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">const</span> multiline = <span class="hljs-string">`foo
                   bar
                   baz`</span>;</code></pre>
<p><em>Note</em> keep in mind that spaces are as you write them, which can surprise you.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> str1 = <span class="hljs-string">`foo
bar`</span>;

<span class="hljs-keyword">const</span> str2 = <span class="hljs-string">`foo
             bar`</span>;

str1 === str2 <span class="hljs-comment">// =&gt; false</span></code></pre>
<h2 id="tagged-template-strings"><a class="markdownIt-Anchor" href="#tagged-template-strings">#</a> Tagged <em>template strings</em></h2>
<p>Let’s dive into another interesting feature of <em>template strings</em>.
Tags are functions that will use just before the <em>template string</em> and they
allow us to enhance the string result.</p>
<p>A tag take an array of “literals” (strings), and then all interpolated
(evaluated) expressions that we can still modify.</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">capitalizeVowels</span>(<span class="hljs-params">strings, ...values</span>) </span>{

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replaceVowels</span>(<span class="hljs-params">string</span>) </span>{
    <span class="hljs-keyword">return</span> string.replace(<span class="hljs-regexp">/[aeiou]/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">c</span>)</span>{
      <span class="hljs-keyword">return</span> c.toUpperCase();
    });
  }

  <span class="hljs-keyword">let</span> result = <span class="hljs-string">""</span>;
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; strings.length; ++i) {
    <span class="hljs-keyword">const</span> nextValue = values[i] || <span class="hljs-string">""</span>;
    result += replaceVowels(strings[i]);
    <span class="hljs-keyword">if</span>(! <span class="hljs-built_in">parseInt</span>(nextValue)) {
      result += replaceVowels(nextValue)
    } <span class="hljs-keyword">else</span> {
      result += nextValue;
    }
  }
  <span class="hljs-keyword">return</span> result;
}


capitalizeVowels<span class="hljs-string">`foo bar ?`</span> <span class="hljs-comment">// =&gt; fOO bAr ?</span>
<span class="hljs-keyword">const</span> n = <span class="hljs-number">42</span>
<span class="hljs-keyword">const</span> c = <span class="hljs-string">"f"</span>
<span class="hljs-keyword">const</span> v = <span class="hljs-string">"o"</span>
capitalizeVowels<span class="hljs-string">`foo <span class="hljs-subst">${ n }</span> bar <span class="hljs-subst">${ c }</span><span class="hljs-subst">${ v }</span><span class="hljs-subst">${ v }</span> ?`</span> <span class="hljs-comment">// =&gt; fOO 42 bAr fOO ?</span></code></pre>
<p>Here is an interesting example of tagged <em>template strings</em> to handle
<a href="http://jaysoo.ca/2014/03/20/i18n-with-es6-template-strings/">i18n for strings</a>.</p>
<h2 id="string-raw"><a class="markdownIt-Anchor" href="#string-raw">#</a> String.raw</h2>
<p>A new function has been added to <code>String</code> prototype that allows us display raw
content so you can see unescaped characters:</p>
<pre><code class="language-js"><span class="hljs-built_in">String</span>.raw<span class="hljs-string">`FOO\nbar`</span> <span class="hljs-comment">// =&gt; FOO\\nbar</span></code></pre>
<h2 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion">#</a> Conclusion</h2>
<p>When you will start to use <em>template strings</em>, you are likely going to like
them. They are clearly really useful in a daily basis.</p>
<p>Almost all
<a href="https://kangax.github.io/compat-table/es6/#test-template_strings">modern browser handle template strings</a>
today, as well as <a href="http://babeljs.io/">Babel</a> and Traceur, so you do not
hesitate to use <em>template strings</em>.</p>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/template-strings/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/template-strings/</guid><pubDate>Mon, 07 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : Promises]]></title><description><![CDATA[<p>With ES2015, you can now very easily write asynchronous code thanks to the
promises.
The concept of promises exists is not new in the JavaScript world, but now
we got an official feature!</p>
<h2 id="what-s-a-promise"><a class="markdownIt-Anchor" href="#what-s-a-promise">#</a> What’s a promise?</h2>
<p>It’s a promise of an incoming value, not available yet. It’s a promise so it can
be fulfilled or not (rejected). If fulfilled, it will give us the the value we
were waiting for. If rejected, we will get the error so we can handle it.</p>
<p>This mechanism allows to avoid the callback hell :</p>
<pre><code class="language-js"><span class="hljs-comment">// With callbacks.</span>
<span class="hljs-comment">// Let's say that all those function are doing async tasks (like http or</span>
<span class="hljs-comment">// database request, fs read...)</span>
<span class="hljs-keyword">const</span> functionWithCallback1 = (callback) =&gt; callback(<span class="hljs-string">'test'</span>, <span class="hljs-literal">undefined</span>)
<span class="hljs-keyword">const</span> functionWithCallback2 = (arg, callback) =&gt; callback(arg, <span class="hljs-literal">undefined</span>)
<span class="hljs-keyword">const</span> functionWithCallback3 = (arg, callback) =&gt; callback(arg, <span class="hljs-literal">undefined</span>)
<span class="hljs-keyword">const</span> functionWithCallback4 = (arg, callback) =&gt; callback(arg, <span class="hljs-literal">undefined</span>)
<span class="hljs-keyword">const</span> functionWithCallback5 = (arg, callback) =&gt; callback(arg, <span class="hljs-literal">undefined</span>)
<span class="hljs-keyword">const</span> functionWithCallback6 = (arg, callback) =&gt; callback(arg, <span class="hljs-literal">undefined</span>)

functionWithCallback1((result1, err) =&gt; {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-keyword">throw</span> err
  }
  functionWithCallback2(result1, (result2, err) =&gt; {
    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-keyword">throw</span> err
    }
    functionWithCallback3(result2, (result3, err) =&gt; {
      <span class="hljs-keyword">if</span> (err) {
        <span class="hljs-keyword">throw</span> err
      }
      functionWithCallback4(result3, (result4, err) =&gt; {
        <span class="hljs-keyword">if</span> (err) {
          <span class="hljs-keyword">throw</span> err
        }
        functionWithCallback5(result4, (result5, err) =&gt; {
          <span class="hljs-keyword">if</span> (err) {
            <span class="hljs-keyword">throw</span> err
          }
          functionWithCallback6(result5, (result6, err) =&gt; {
            <span class="hljs-keyword">if</span> (err) {
              <span class="hljs-keyword">throw</span> err
            }
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Example with callbacks: <span class="hljs-subst">${result6}</span>`</span>)
          })
        })
      })
    })
  })
})

<span class="hljs-comment">// Now the same thing with promises</span>
<span class="hljs-keyword">const</span> functionWithPromise1 = () =&gt; <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'test'</span>)
<span class="hljs-keyword">const</span> functionWithPromise2 = (arg) =&gt; <span class="hljs-built_in">Promise</span>.resolve(arg)
<span class="hljs-keyword">const</span> functionWithPromise3 = (arg) =&gt; <span class="hljs-built_in">Promise</span>.resolve(arg)
<span class="hljs-keyword">const</span> functionWithPromise4 = (arg) =&gt; <span class="hljs-built_in">Promise</span>.resolve(arg)
<span class="hljs-keyword">const</span> functionWithPromise5 = (arg) =&gt; <span class="hljs-built_in">Promise</span>.resolve(arg)
<span class="hljs-keyword">const</span> functionWithPromise6 = (arg) =&gt; <span class="hljs-built_in">Promise</span>.resolve(arg)

functionWithPromise1()
  .then(functionWithPromise2)
  .then(functionWithPromise3)
  .then(functionWithPromise4)
  .then(functionWithPromise5)
  .then(functionWithPromise6)
  .then(result =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Example with promises: <span class="hljs-subst">${result}</span>`</span>))
  .catch(err =&gt; {
    <span class="hljs-keyword">throw</span> err
  })</code></pre>
<p>As you can see, example with promises is clear and more concise.</p>
<h2 id="that-s-cool-how-can-i-use-promises"><a class="markdownIt-Anchor" href="#that-s-cool-how-can-i-use-promises">#</a> That’s cool. How can I use promises?</h2>
<p>A promise can have different status:</p>
<ul>
<li>in progress: value is not ready yet</li>
<li>resolved: value is here, we can use it</li>
<li>rejected: an error has been thrown, we should handle it.</li>
</ul>
<p>A promise have 2 functions: <code>then</code> and <code>catch</code>.
You can use <code>then</code> to wait for the result (or handle an error), and <code>catch</code> to
catch all possibles errors of one promise or more.</p>
<p>Let’s see how to use promises with an example of the incoming standardized
<a href="https://fetch.spec.whatwg.org"><code>fetch</code></a> method.</p>
<pre><code class="language-js"><span class="hljs-comment">// At this moment, promise is in progress</span>
<span class="hljs-keyword">const</span> fetchPromise = fetch(<span class="hljs-string">'http://putaindecode.io'</span>)

<span class="hljs-comment">// When promise is resolved, you go a value you can work with</span>
<span class="hljs-keyword">const</span> parsePromise = fetchPromise.then(fetchResult =&gt; {
  <span class="hljs-comment">// I can return a new result that can be used as a new promise</span>
  <span class="hljs-comment">// Here we call .text() which parse the content of the request and return</span>
  <span class="hljs-comment">// promise</span>
  <span class="hljs-keyword">return</span> fetchResult.text()
})

<span class="hljs-comment">// When parsing is done, we can work with the content</span>
parsePromise.then(textResult =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Here is the text result : <span class="hljs-subst">${textResult}</span>`</span>)
})

<span class="hljs-comment">// If the request encounter an issue, promise might be rejected with an error</span>
fetchPromise.catch(fetchError =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`We got an issue during the request`</span>, fetchError)
})

<span class="hljs-comment">// If there is an issue during the parsing, we can handle it too</span>
parsePromise.catch(parseError =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"We got an issue during the parsing"</span>, parseError)
})

<span class="hljs-comment">// The same can be written like this</span>
fetch(<span class="hljs-string">'http://putaindecode.io'</span>)
  .then((fetchResult) =&gt; fetchResult.text())
  .then((textResult) =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Here is the text result : <span class="hljs-subst">${textResult}</span>`</span>)
  })
  .catch((error) =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`We got an issue during the request or the parsing`</span>, fetchError)
  })

<span class="hljs-comment">// Or like this</span>
fetch(<span class="hljs-string">'http://putaindecode.io'</span>)
  .then(
    (fetchResult) =&gt; {
      <span class="hljs-keyword">return</span> fetchResult.text()
    },
    (fetchError) =&gt; {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`We got an issue during the request`</span>, fetchError)
    })
  .then(
    (textResult) =&gt; {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Here is the text result : <span class="hljs-subst">${textResult}</span>`</span>)
    },
    (parseError) =&gt; {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"We got an issue during the parsing"</span>, parseError)
    }
  )</code></pre>
<h2 id="how-do-i-create-my-own-promises"><a class="markdownIt-Anchor" href="#how-do-i-create-my-own-promises">#</a> How do I create my own promises?</h2>
<p>Using a promise is nice, but creating yours is even better. Let’s be clear: it’s
easy.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> functionThatReturnAPromise = (success) =&gt; {
  <span class="hljs-comment">// We will need to use Promise class to use one.</span>
  <span class="hljs-comment">// constructor takes 2 arguments:</span>
  <span class="hljs-comment">// - resolve, a callback to pass the value you want to send</span>
  <span class="hljs-comment">// - reject, a callback to throw an error</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; {
    <span class="hljs-keyword">if</span> (success) {
      resolve(<span class="hljs-string">'success'</span>)
    }
    <span class="hljs-keyword">else</span> {
      reject(<span class="hljs-string">'failed'</span>)
    }
  })
}

<span class="hljs-comment">// You can use this promise like this</span>
functionThatReturnAPromise(success)
  .then(res =&gt; <span class="hljs-built_in">console</span>.log(res))
  .catch(error =&gt; <span class="hljs-built_in">console</span>.log(error))

<span class="hljs-comment">// In our case, the previous example can be also written</span>
functionThatReturnAPromise(success)
  .then(
    (res) =&gt; <span class="hljs-built_in">console</span>.log(res),
    (error) =&gt; <span class="hljs-built_in">console</span>.log(error)
  )</code></pre>
<h2 id="what-s-next"><a class="markdownIt-Anchor" href="#what-s-next">#</a> What’s next?</h2>
<p>A new way to write asynchronous will land in JavaScript with <code>async</code> and <code>await</code>
keywords, but we will need to way another ES year (or two) for it !</p>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/promises/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/promises/</guid><pubDate>Sun, 06 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : les promesses]]></title><description><![CDATA[<p>ES2015 apporte une fonctionnalité simplifiant grandement l’asynchrone en
JavaScript, les promesses ! Visible depuis longtemps dans l’écosystème
JavaScript grâce a diverses librairies, on peut maintenant utiliser directement
la spécification officielle.</p>
<h2 id="c-est-quoi-une-promesse"><a class="markdownIt-Anchor" href="#c-est-quoi-une-promesse">#</a> C’est quoi une promesse ?</h2>
<p>Et bien comme son nom l’indique vous pouvez voir ça comme la promesse que vous
allez recevoir une valeur. Comme toute promesse, elle peut être tenue,
la valeur est arrivée et on peut s’en servir, ou ne pas l’être, dans ce cas
une erreur arrive et on peut réagir en conséquence.</p>
<p>Ce mécanisme permet de remplacer les callbacks d’une manière plus élégante. Au
revoir, la suite de callbacks qui rend votre code illisible ! Vous ne me croyez
pas ? Voici un exemple pour vous le prouver :</p>
<pre><code class="language-js"><span class="hljs-comment">// En utilisant les callbacks</span>
<span class="hljs-comment">// Imaginez que chacune de ces fonctions effectue des tâches asynchrones</span>
<span class="hljs-comment">// plus ou moins complexes (requête HTTP, appel à une base de données</span>
<span class="hljs-comment">// ou encore lecture de fichier)</span>
<span class="hljs-keyword">const</span> functionWithCallback1 = (callback) =&gt; callback(<span class="hljs-string">'test'</span>, <span class="hljs-literal">undefined</span>)
<span class="hljs-keyword">const</span> functionWithCallback2 = (arg, callback) =&gt; callback(arg, <span class="hljs-literal">undefined</span>)
<span class="hljs-keyword">const</span> functionWithCallback3 = (arg, callback) =&gt; callback(arg, <span class="hljs-literal">undefined</span>)
<span class="hljs-keyword">const</span> functionWithCallback4 = (arg, callback) =&gt; callback(arg, <span class="hljs-literal">undefined</span>)
<span class="hljs-keyword">const</span> functionWithCallback5 = (arg, callback) =&gt; callback(arg, <span class="hljs-literal">undefined</span>)
<span class="hljs-keyword">const</span> functionWithCallback6 = (arg, callback) =&gt; callback(arg, <span class="hljs-literal">undefined</span>)

functionWithCallback1((result1, err) =&gt; {
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-keyword">throw</span> err
  }
  functionWithCallback2(result1, (result2, err) =&gt; {
    <span class="hljs-keyword">if</span> (err) {
      <span class="hljs-keyword">throw</span> err
    }
    functionWithCallback3(result2, (result3, err) =&gt; {
      <span class="hljs-keyword">if</span> (err) {
        <span class="hljs-keyword">throw</span> err
      }
      functionWithCallback4(result3, (result4, err) =&gt; {
        <span class="hljs-keyword">if</span> (err) {
          <span class="hljs-keyword">throw</span> err
        }
        functionWithCallback5(result4, (result5, err) =&gt; {
          <span class="hljs-keyword">if</span> (err) {
            <span class="hljs-keyword">throw</span> err
          }
          functionWithCallback6(result5, (result6, err) =&gt; {
            <span class="hljs-keyword">if</span> (err) {
              <span class="hljs-keyword">throw</span> err
            }
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Exemple avec les callback : <span class="hljs-subst">${result6}</span>`</span>)
          })
        })
      })
    })
  })
})

<span class="hljs-comment">// Et maintenant, en utilisant les promesses</span>
<span class="hljs-keyword">const</span> functionWithPromise1 = () =&gt; <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'test'</span>)
<span class="hljs-keyword">const</span> functionWithPromise2 = (arg) =&gt; <span class="hljs-built_in">Promise</span>.resolve(arg)
<span class="hljs-keyword">const</span> functionWithPromise3 = (arg) =&gt; <span class="hljs-built_in">Promise</span>.resolve(arg)
<span class="hljs-keyword">const</span> functionWithPromise4 = (arg) =&gt; <span class="hljs-built_in">Promise</span>.resolve(arg)
<span class="hljs-keyword">const</span> functionWithPromise5 = (arg) =&gt; <span class="hljs-built_in">Promise</span>.resolve(arg)
<span class="hljs-keyword">const</span> functionWithPromise6 = (arg) =&gt; <span class="hljs-built_in">Promise</span>.resolve(arg)

functionWithPromise1()
  .then(functionWithPromise2)
  .then(functionWithPromise3)
  .then(functionWithPromise4)
  .then(functionWithPromise5)
  .then(functionWithPromise6)
  .then(result =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Exemple avec les promesses : <span class="hljs-subst">${result}</span>`</span>))
  .catch(err =&gt; {
    <span class="hljs-keyword">throw</span> err
  })</code></pre>
<p>Comme vous pouvez le voir, l’exemple avec les promesses est tout de même plus
lisible !</p>
<h2 id="trop-bien-comment-je-les-utilise"><a class="markdownIt-Anchor" href="#trop-bien-comment-je-les-utilise">#</a> Trop bien ! Comment je les utilise ?</h2>
<p>Une promesse peut avoir plusieurs états au cours de son existence :</p>
<ul>
<li>en cours : la valeur qu’elle contient n’est pas encore arrivée</li>
<li>résolue : la valeur est arrivée, on peut l’utiliser</li>
<li>rejetée : une erreur est survenue, on peut y réagir</li>
</ul>
<p>Une promesse possède 2 fonctions : <code>then</code> et <code>catch</code>, vous pouvez utiliser
<code>then</code> pour récupérer le resultat ou l’erreur d’une promesse et <code>catch</code> pour
récupérer l’erreur d’une ou plusieurs promesses.</p>
<p>Voyons comment utiliser les promesses à l’aide de la future implémentation de
<a href="https://fetch.spec.whatwg.org"><code>fetch</code></a>.</p>
<pre><code class="language-js"><span class="hljs-comment">// À ce moment, la promesse est en attente</span>
<span class="hljs-keyword">const</span> fetchPromise = fetch(<span class="hljs-string">'http://putaindecode.io'</span>)

<span class="hljs-comment">// Quand la requête est terminée la promesse est résolue avec le résultat de</span>
<span class="hljs-comment">// la requête</span>
<span class="hljs-keyword">const</span> parsePromise = fetchPromise.then(fetchResult =&gt; {
  <span class="hljs-comment">// Je peux retourner une nouvelle promesse à partir d'un then, ici</span>
  <span class="hljs-comment">// j'appelle .text() qui parse le contenu de la requête et retourne</span>
  <span class="hljs-comment">// une promesse</span>
  <span class="hljs-keyword">return</span> fetchResult.text()
})

<span class="hljs-comment">// Quand le parsing est terminé, je peux recuperer son contenu</span>
parsePromise.then(textResult =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Voici le résultat : <span class="hljs-subst">${textResult}</span>`</span>)
})

<span class="hljs-comment">// Si la requête a un problème, la promesse est rejetée avec une erreur</span>
fetchPromise.catch(fetchError =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Une erreur a eu lieu pendant la requête"</span>, fetchError)
})

<span class="hljs-comment">// S'il y a une erreur pendant le parsing, je peux la récupérer</span>
parsePromise.catch(parseError =&gt; {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Une erreur a eu lieu pendant le parsing"</span>, parseError)
})

<span class="hljs-comment">// Cela peut aussi être écrit</span>
fetch(<span class="hljs-string">'http://putaindecode.io'</span>)
  .then(fetchResult =&gt; fetchResult.text())
  .then(textResult =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Voici le résultat : <span class="hljs-subst">${textResult}</span>`</span>)
  })
  .catch(error =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Une erreur a eu lieu pendant la requête ou le parsing"</span>, fetchError)
  })

<span class="hljs-comment">// Ou encore</span>
fetch(<span class="hljs-string">'http://putaindecode.io'</span>)
  .then(
    fetchResult =&gt; {
      <span class="hljs-keyword">return</span> fetchResult.text()
    },
    fetchError =&gt; {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Une erreur a eu lieu pendant la requête"</span>, fetchError)
    }
  )
  .then(
    textResult =&gt; {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Voici le résultat : <span class="hljs-subst">${textResult}</span>`</span>)
    },
    parseError =&gt; {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Une erreur a eu lieu pendant le parsing"</span>, parseError)
    }
  )</code></pre>
<h2 id="mais-comment-je-cr-e-mes-propres-promesses"><a class="markdownIt-Anchor" href="#mais-comment-je-cr-e-mes-propres-promesses">#</a> Mais comment je crée mes propres promesses ?</h2>
<p>C’est bien beau d’utiliser les promesses, mais c’est encore mieux de savoir
créer les vôtres ! Je vous rassure, c’est très simple.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> functionThatReturnAPromise = (success) =&gt; {
  <span class="hljs-comment">// On utilise la classe Promise pour en créer une, le constructeur prend 2</span>
  <span class="hljs-comment">// fonctions en paramètre :</span>
  <span class="hljs-comment">// - resolve que l'on pourra appeler avec le résultat de notre fonction</span>
  <span class="hljs-comment">// - reject que l'on pourra appeler avec une erreur s'il y a une erreur</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; {
    <span class="hljs-keyword">if</span> (success) {
      resolve(<span class="hljs-string">'success'</span>)
    }
    <span class="hljs-keyword">else</span> {
      reject(<span class="hljs-string">'failed'</span>)
    }
  })
}

<span class="hljs-comment">// Vous pouvez maintenant utiliser votre fonction comme vu précédemment</span>
functionThatReturnAPromise(success)
  .then(res =&gt; <span class="hljs-built_in">console</span>.log(res))
  .catch(error =&gt; <span class="hljs-built_in">console</span>.log(error))

<span class="hljs-comment">// équivalent dans notre cas à</span>
functionThatReturnAPromise(success)
  .then(
    (res) =&gt; <span class="hljs-built_in">console</span>.log(res),
    (error) =&gt; <span class="hljs-built_in">console</span>.log(error)
  )</code></pre>
<h2 id="et-demain"><a class="markdownIt-Anchor" href="#et-demain">#</a> Et demain ?</h2>
<p>Une fonctionnalité encore plus pratique que les promesses arrive en JavaScript,
les mots-clés <code>async</code> et <code>await</code> ! Ces mots-clés vous permettront d’avoir un
code encore plus lisible quand vous ferez de l’asynchrone, mais ça ne concerne
pas ES2015 :)</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/promises/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/promises/</guid><pubDate>Sun, 06 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : les classes]]></title><description><![CDATA[<p>Les classes introduites par <code>ES2015</code> ne sont clairement que du sucre syntaxique.
Elles n’apportent rien de plus en terme de fonctionnalité. Toutefois, l’objectif
de cette évolution est de rendre le code plus lisible et plus facilement
accessible.</p>
<h2 id="d-claration-de-classes"><a class="markdownIt-Anchor" href="#d-claration-de-classes">#</a> Déclaration de classes</h2>
<p>Oubliez les fonctions anonymes et les prototypes, la sémantique a pris le
relais, comme vous pouvez le constater dans l’exemple de déclaration de la
classe <code>User</code> :</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-comment">// méthode constructor</span>
  constructor(firstname, lastname) {
    <span class="hljs-keyword">this</span>.firstname = firstname;
    <span class="hljs-keyword">this</span>.lastname = lastname;
  }

  sayName() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${this.firstname}</span> <span class="hljs-subst">${this.lastname}</span>`</span>
  }
}

<span class="hljs-comment">// instanciation</span>
<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"John"</span>, <span class="hljs-string">"Doe"</span>)

<span class="hljs-comment">// appel de la méthode sayName()</span>
<span class="hljs-built_in">console</span>.log(user.sayName()) <span class="hljs-comment">// John Doe</span></code></pre>
<p>Pour rappel, voici une <a href="https://gist.github.com/magsout/a876b2fa8240a987e523">façon possible
d’écrire</a> cette classe en
<code>es5</code> :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">firstname, lastname</span>) </span>{
  <span class="hljs-keyword">if</span>(!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> User)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Class constructors cannot be invoked without 'new'"</span>)
  }
  <span class="hljs-keyword">this</span>.firstname = firstname
  <span class="hljs-keyword">this</span>.lastname = lastname
}

User.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstname + <span class="hljs-string">" "</span> + <span class="hljs-keyword">this</span>.lastname
}

<span class="hljs-comment">// instanciation</span>
<span class="hljs-keyword">var</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"John"</span>, <span class="hljs-string">"Doe"</span>)

<span class="hljs-comment">// appel de la méthode sayName()</span>
<span class="hljs-built_in">console</span>.log(user.sayName()) <span class="hljs-comment">// John Doe</span></code></pre>
<h2 id="expressions-de-classes"><a class="markdownIt-Anchor" href="#expressions-de-classes">#</a> Expressions de classes</h2>
<p>Toutes les méthodes s’écrivent comme de simples fonctions à l’intérieur de la
classe. Bien entendu, les getter/setter sont toujours de la partie mais bien
plus simples à utiliser :</p>
<pre><code class="language-JS"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-comment">// constructor</span>
  constructor(firstname, lastname, type) {
    <span class="hljs-keyword">this</span>.firstname = firstname
    <span class="hljs-keyword">this</span>.lastname = lastname
    <span class="hljs-keyword">this</span>.type = type
  }

  <span class="hljs-comment">// méthode</span>
  sayName() {
   <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${this.firstname}</span>  <span class="hljs-subst">${this.lastname}</span>`</span>
  }

  <span class="hljs-comment">// getter</span>
  get role() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.type
  }

  <span class="hljs-comment">// setter</span>
  set role(value) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.type = value
  }
}

<span class="hljs-comment">// le `new` est obligatoire pour appeler une classe</span>
<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"John"</span>, <span class="hljs-string">"Doe"</span>, <span class="hljs-string">"Contributor"</span>)

<span class="hljs-built_in">console</span>.log(user.sayName()) <span class="hljs-comment">// John Doe</span>
<span class="hljs-built_in">console</span>.log(user.role) <span class="hljs-comment">// Contributor</span>
user.role = <span class="hljs-string">"owner"</span>
<span class="hljs-built_in">console</span>.log(user.role) <span class="hljs-comment">// Owner</span></code></pre>
<h2 id="l-h-ritage"><a class="markdownIt-Anchor" href="#l-h-ritage">#</a> L’héritage</h2>
<p>Pour qu’une sous-classe hérite d’une autre classe on utilisera le mot
clé <code>extends</code>.</p>
<p>En utilisant notre exemple précédent :</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Contributor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">User</span> </span>{
  constructor(firstname, lastname, numberCommit) {

    <span class="hljs-comment">// le mot clé super est utilisé comme super contructeur. Il permet d'appeler</span>
    <span class="hljs-comment">// et d'avoir accès aux méthodes du parent</span>
    <span class="hljs-keyword">super</span>(firstname, lastname)
    <span class="hljs-keyword">this</span>.numberCommit = numberCommit
  }

  sayNameWithCommit() {
    <span class="hljs-comment">// on peut appeler une méthode de la classe parente avec `super.method`</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.sayName() + <span class="hljs-string">" "</span> + <span class="hljs-keyword">this</span>.sayNumberCommit()
  }

  sayNumberCommit() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.numberCommit
  }
}

<span class="hljs-comment">// instanciation</span>
<span class="hljs-keyword">const</span> contributor = <span class="hljs-keyword">new</span> Contributor(<span class="hljs-string">'Jane'</span>, <span class="hljs-string">'Smith'</span>, <span class="hljs-number">10</span>)

<span class="hljs-comment">// appel de la méthode sayName()</span>
<span class="hljs-built_in">console</span>.log(contributor.sayName())
<span class="hljs-built_in">console</span>.log(contributor.sayNumberCommit())</code></pre>
<p><strong>Rappel : <a href="https://www.youtube.com/watch?v=wfMtDGfHWpA">préférez la composition à l’héritage</a>.</strong></p>
<h2 id="that-s-it"><a class="markdownIt-Anchor" href="#that-s-it">#</a> That’s it</h2>
<p>Concrètement, tout ce qui est possible de faire avec cette nouvelle notation
l’était bien entendu
<a href="https://gist.github.com/bloodyowl/7edc9c973d2236ed17e1">avant</a>.</p>
<p>Au final, on gagne en clarté, en lisibilité et donc en maintenabilité.</p>
<p>À l’heure actuelle, il est nécessaire de passer par un transpileur comme
<a href="https://babeljs.io/">babel</a> pour utiliser les classes.</p>
<p>Une dernière petite chose, en utilisant les classes on active automatiquement le
<a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Strict_mode">mode strict</a>,
il n’est donc pas nécessaire de le rajouter manuellement.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/es2015/classes/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/es2015/classes/</guid><pubDate>Sat, 05 Dec 2015 00:00:00 GMT</pubDate></item><item><title><![CDATA[ES6, ES2015 : Classes]]></title><description><![CDATA[<p>Classes introduced by ES2015 are just some syntax sugar.
They don’t really bring anything.
That said, this can helps to improve code readability and make the code more
accessible.</p>
<h2 id="class-declaration"><a class="markdownIt-Anchor" href="#class-declaration">#</a> Class declaration</h2>
<p>Forget functions and prototypes, semantic is taking the relay as you will see in
the following example :</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  constructor(firstname, lastname) {
    <span class="hljs-keyword">this</span>.firstname = firstname;
    <span class="hljs-keyword">this</span>.lastname = lastname;
  }

  sayName() {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${this.firstname}</span> <span class="hljs-subst">${this.lastname}</span>`</span>
  }
}

<span class="hljs-comment">// instanciation</span>
<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"John"</span>, <span class="hljs-string">"Doe"</span>)

<span class="hljs-comment">// call of the method sayName()</span>
<span class="hljs-built_in">console</span>.log(user.sayName()) <span class="hljs-comment">// John Doe</span></code></pre>
<p>As a reminder, here is one
<a href="https://gist.github.com/magsout/a876b2fa8240a987e523">way to code</a>
this class in <code>es5</code> :</p>
<pre><code class="language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">firstname, lastname</span>) </span>{
  <span class="hljs-keyword">if</span>(!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> User)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Class constructors cannot be invoked without 'new'"</span>)
  }
  <span class="hljs-keyword">this</span>.firstname = firstname
  <span class="hljs-keyword">this</span>.lastname = lastname
}

User.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstname + <span class="hljs-string">" "</span> + <span class="hljs-keyword">this</span>.lastname
}

<span class="hljs-comment">// instanciation</span>
<span class="hljs-keyword">var</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"John"</span>, <span class="hljs-string">"Doe"</span>)

<span class="hljs-comment">// call of the method sayName()</span>
<span class="hljs-built_in">console</span>.log(user.sayName()) <span class="hljs-comment">// John Doe</span></code></pre>
<h2 id="classes-expressions"><a class="markdownIt-Anchor" href="#classes-expressions">#</a> Classes expressions</h2>
<p>All methods should be written as simple function inside the class.
You might denote the nice way to write getter and setter :</p>
<pre><code class="language-JS"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  constructor(firstname, lastname, type) {
    <span class="hljs-keyword">this</span>.firstname = firstname
    <span class="hljs-keyword">this</span>.lastname = lastname
    <span class="hljs-keyword">this</span>.type = type
  }

  <span class="hljs-comment">// method</span>
  sayName() {
   <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${this.firstname}</span>  <span class="hljs-subst">${this.lastname}</span>`</span>
  }

  <span class="hljs-comment">// getter</span>
  get role() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.type
  }

  <span class="hljs-comment">// setter</span>
  set role(value) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.type = value
  }
}

<span class="hljs-comment">// the `new` is mandatory to instanciate a class</span>
<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"John"</span>, <span class="hljs-string">"Doe"</span>, <span class="hljs-string">"Contributor"</span>)

<span class="hljs-built_in">console</span>.log(user.sayName()) <span class="hljs-comment">// John Doe</span>
<span class="hljs-built_in">console</span>.log(user.role) <span class="hljs-comment">// Contributor</span>
user.role = <span class="hljs-string">"owner"</span>
<span class="hljs-built_in">console</span>.log(user.role) <span class="hljs-comment">// Owner</span></code></pre>
<h2 id="inheritance"><a class="markdownIt-Anchor" href="#inheritance">#</a> Inheritance</h2>
<p>In order to have a class that inherite from another, we have the <code>extends</code>
keyword.</p>
<p>Here is the an example :</p>
<pre><code class="language-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Contributor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">User</span> </span>{
  constructor(firstname, lastname, numberCommit) {

    <span class="hljs-comment">// keyword `super` is used to call the constructor of the parent class</span>
    <span class="hljs-keyword">super</span>(firstname, lastname)
    <span class="hljs-keyword">this</span>.numberCommit = numberCommit
  }

  sayNameWithCommit() {
    <span class="hljs-comment">// we can can also use `super` to call a method of the parent class</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.sayName() + <span class="hljs-string">" "</span> + <span class="hljs-keyword">this</span>.sayNumberCommit()
  }

  sayNumberCommit() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.numberCommit
  }
}

<span class="hljs-keyword">const</span> contributor = <span class="hljs-keyword">new</span> Contributor(<span class="hljs-string">'Jane'</span>, <span class="hljs-string">'Smith'</span>, <span class="hljs-number">10</span>)

<span class="hljs-built_in">console</span>.log(contributor.sayName())
<span class="hljs-built_in">console</span>.log(contributor.sayNumberCommit())</code></pre>
<p><strong>Reminder: <a href="https://www.youtube.com/watch?v=wfMtDGfHWpA">prefer inheritance to composition</a>.</strong></p>
<h2 id="that-s-it"><a class="markdownIt-Anchor" href="#that-s-it">#</a> That’s it</h2>
<p>As you saw, all what you can do know was already possible
<a href="https://gist.github.com/bloodyowl/7edc9c973d2236ed17e1">before</a>.</p>
<p>We just have a more readable code that should be more easily maintainable.</p>
<p>For now, you will need to use a transpiler like <a href="https://babeljs.io/">babel</a>
to be able to use classes.</p>
<p>One last thing: when you are in a class context,
<a href="https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Strict_mode">strict mode</a>
is enabled automatically.</p>
]]></description><link>http://putaindecode.io/en/articles/js/es2015/classes/</link><guid isPermaLink="true">http://putaindecode.io/en/articles/js/es2015/classes/</guid><pubDate>Sat, 05 Dec 2015 00:00:00 GMT</pubDate></item></channel></rss>